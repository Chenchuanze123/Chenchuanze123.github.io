<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>海南大学算法设计与分析--期末复习 | CFuYuan'sBlog</title><meta name="keywords" content="贪心法,动态规划法,分支限界法,回溯法,分治法,归并排序,快速排序,折半查找,二叉树查找,堆排序,多段图的最短路径问题"><meta name="author" content="CFuYuan"><meta name="copyright" content="CFuYuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引言快要期末考试啦，对算法做一个总结，以备自己后续的学习。 看之前可以先重点看看目录，这样可以明确这篇文章的结构，并且迅速找到需要的知识 算法基础知识算法的五个特性：（必考） 输入 输出 有穷 可行 确定  常用的描述算法的方法： 自然语言 流程图 伪代码 程序设计语言   时间复杂度：​    概念：  O(n):用来描述增长率的上限 Ω(n):用来描述增长率的下限  最优算法：大Ω符号常常与大">
<meta property="og:type" content="article">
<meta property="og:title" content="海南大学算法设计与分析--期末复习">
<meta property="og:url" content="https://chenchuanze123.github.io/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="CFuYuan&#39;sBlog">
<meta property="og:description" content="引言快要期末考试啦，对算法做一个总结，以备自己后续的学习。 看之前可以先重点看看目录，这样可以明确这篇文章的结构，并且迅速找到需要的知识 算法基础知识算法的五个特性：（必考） 输入 输出 有穷 可行 确定  常用的描述算法的方法： 自然语言 流程图 伪代码 程序设计语言   时间复杂度：​    概念：  O(n):用来描述增长率的上限 Ω(n):用来描述增长率的下限  最优算法：大Ω符号常常与大">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenchuanze123.github.io/img/be2a0337711d4b5189245e6c670a2d5b.png">
<meta property="article:published_time" content="2022-06-07T02:02:50.000Z">
<meta property="article:modified_time" content="2024-01-19T09:58:03.748Z">
<meta property="article:author" content="CFuYuan">
<meta property="article:tag" content="贪心法">
<meta property="article:tag" content="动态规划法">
<meta property="article:tag" content="分支限界法">
<meta property="article:tag" content="回溯法">
<meta property="article:tag" content="分治法">
<meta property="article:tag" content="归并排序">
<meta property="article:tag" content="快速排序">
<meta property="article:tag" content="折半查找">
<meta property="article:tag" content="二叉树查找">
<meta property="article:tag" content="堆排序">
<meta property="article:tag" content="多段图的最短路径问题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenchuanze123.github.io/img/be2a0337711d4b5189245e6c670a2d5b.png"><link rel="shortcut icon" href="/img/download.jpg"><link rel="canonical" href="https://chenchuanze123.github.io/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: CFuYuan","link":"链接: ","source":"来源: CFuYuan'sBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '海南大学算法设计与分析--期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-19 17:58:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="CFuYuan'sBlog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/76c39a0fa42f4847eb2ef67b82932bc.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-tags"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/be2a0337711d4b5189245e6c670a2d5b.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CFuYuan'sBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-tags"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">海南大学算法设计与分析--期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-07T02:02:50.000Z" title="发表于 2022-06-07 10:02:50">2022-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-19T09:58:03.748Z" title="更新于 2024-01-19 17:58:03">2024-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="海南大学算法设计与分析--期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>快要期末考试啦，对算法做一个总结，以备自己后续的学习。</p>
<p>看之前可以先重点看看目录，这样可以明确这篇文章的结构，并且迅速找到需要的知识</p>
<h1 id="算法基础知识"><a href="#算法基础知识" class="headerlink" title="算法基础知识"></a>算法基础知识</h1><h2 id="算法的五个特性：（必考）"><a href="#算法的五个特性：（必考）" class="headerlink" title="算法的五个特性：（必考）"></a>算法的五个特性：（必考）</h2><ol>
<li>输入</li>
<li>输出</li>
<li>有穷</li>
<li>可行</li>
<li>确定</li>
</ol>
<h2 id="常用的描述算法的方法："><a href="#常用的描述算法的方法：" class="headerlink" title="常用的描述算法的方法："></a>常用的描述算法的方法：</h2><ul>
<li>自然语言</li>
<li>流程图</li>
<li>伪代码</li>
<li>程序设计语言 </li>
</ul>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>​    概念：</p>
<ul>
<li>O(n):用来描述增长率的上限</li>
<li>Ω(n):用来描述增长率的下限</li>
</ul>
<p><strong>最优算法</strong>：大Ω符号常常与大O符号配合以证明某问题的一个特定算法是该问题的最优算法，或是该问题中的某算法类中的最优算法。一般情况下，如果能够证明某问题的时间下界是Ω(g(n))来求解该问题的任何算法，都认为是求解该问题的最优算法</p>
<p><strong>主定理</strong>：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/cf1accd1cf0c44e6aa731c3e02ca059a.png" alt="在这里插入图片描述"></p>
<p>习题：</p>
<h1 id="基本的算法设计技术"><a href="#基本的算法设计技术" class="headerlink" title="基本的算法设计技术"></a>基本的算法设计技术</h1><h2 id="分治法与减治法"><a href="#分治法与减治法" class="headerlink" title="分治法与减治法"></a>分治法与减治法</h2><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><p>​    <strong>分治法</strong>：将一个难以直接解决的大问题划分成一些规模较小的子问题，分别求解各个子问题，然后将各个子问题的解合并。分为三步：划分、求解子问题、合并。</p>
<p>​    <strong>减治法</strong>：将一个难以直接解决的大问题划分为若干子问题，但是这些子问题不需要分别求解，只需求解其中的一个子问题，因而也就无需对子问题的解进行合并。</p>
<h3 id="同与异："><a href="#同与异：" class="headerlink" title="同与异："></a>同与异：</h3><p>同：都需要划分子问题，都需要求解子问题;它俩的编程思想都是<strong>递归</strong></p>
<p>异：减治法无须合并子问题，只需要找出子问题的解与原问题解之间的对应关系，或直接求解子问题便得原问题的解。</p>
<h3 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h3><p>分治法：最好使子问题的规模大致相同（子问题平衡）</p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><p>​    分治法：</p>
<ol>
<li>归并排序</li>
<li>快速排序</li>
</ol>
<p>​     减治法：</p>
<ol>
<li>折半查找</li>
<li>二叉查找树</li>
<li>堆排序</li>
</ol>
<p><strong>对于排序与查找算法没有最好的，只有最合适的。</strong></p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>核心思想</strong>：</p>
<p>不断地将序列一分为二（若是奇数个数则向上取整，例如7/2=3.5向上取整则为4，因此左边四个数，右边三个数）直至分到只有一个数为止，然后开始合并并排序 。</p>
<p><strong>详细解读</strong>：<img src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-5066-20161218163120151-452283750.png" alt="img"></p>
<p> 首先是分然后是治，先不断地一分为二，然后不断地合二为一。</p>
<p>我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现合并的步骤。 </p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-2034-20161218194508761-468169540.png" alt="img"><img src="https://www.runoob.com/wp-content/uploads/2019/05/1557906108-7614-20161218194621308-588010220.png" alt="img"></p>
<p>下面是两个应用，一个为偶序列，一个为奇序列</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/398664d194e84951b0cebd1f9e5e1856.jpeg" alt="请添加图片描述"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == end - start)<span class="comment">//如果区间中只有两个元素，则对这两个元素进行排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] &gt; data[end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp  = data[start];</span><br><span class="line">            data[start] = data[end];</span><br><span class="line">            data[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == end - start)<span class="comment">//如果只有一个元素，则不用排序</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//继续划分子区间，分别对左右子区间进行排序</span></span><br><span class="line">        <span class="built_in">merge_sort</span>(data,start,(end-start+<span class="number">1</span>)/<span class="number">2</span>+start,result);</span><br><span class="line">        <span class="built_in">merge_sort</span>(data,(end-start+<span class="number">1</span>)/<span class="number">2</span>+start+<span class="number">1</span>,end,result);</span><br><span class="line">        <span class="comment">//开始归并已经排好序的start到end之间的数据</span></span><br><span class="line">        <span class="built_in">merge</span>(data,start,end,result);</span><br><span class="line">        <span class="comment">//把排序后的区间数据复制到原始数据中去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt;= end;++i)</span><br><span class="line">            data[i] = result[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> merge的过程为： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *data,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> *result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_length = (end - start + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//左部分区间的数据元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> left_index = start;</span><br><span class="line">    <span class="keyword">int</span> right_index = start + left_length;</span><br><span class="line">    <span class="keyword">int</span> result_index = start;</span><br><span class="line">    <span class="keyword">while</span>(left_index &lt; start + left_length &amp;&amp; right_index &lt; end+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对分别已经排好序的左区间和右区间进行合并</span></span><br><span class="line">        <span class="keyword">if</span>(data[left_index] &lt;= data[right_index])</span><br><span class="line">            result[result_index++] = data[left_index++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result[result_index++] = data[right_index++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(left_index &lt; start + left_length)</span><br><span class="line">        result[result_index++] = data[left_index++];</span><br><span class="line">    <span class="keyword">while</span>(right_index &lt; end+<span class="number">1</span>)</span><br><span class="line">        result[result_index++] = data[right_index++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 现在对程序进行测试： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">33</span>,<span class="number">16</span>,<span class="number">20</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> result[length];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before sorted:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;++i)</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After sorted:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">merge_sort</span>(data,<span class="number">0</span>,length<span class="number">-1</span>,result);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;++i)</span><br><span class="line">        cout &lt;&lt; data[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/69fde6abaa6fbf081c0cd299bc73e87a.png" alt="img"></p>
<p><strong>总结</strong>：</p>
<p>归并排序的性能不受输入数据的影响，始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h4 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h4> <HR> 

<p><strong>核心思想</strong></p>
<p> 快速排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第 1 个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p>
<p>因此可以总结为三点：</p>
<ul>
<li>1．先从数列中取出一个数作为基准数。</li>
<li>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>3．再对左右区间重复第二步，直到各区间只有一个数。  </li>
</ul>
<p> 那么移动元素，该怎么移动呢？ </p>
<p> 快速排序的操作是这样的：首先从数列的最右边（也就是最后一个数字）开始往左边找，我们设这个下标为 j，也就是进行减减操作（j–），找到第 1 个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，设这个下标为 i，然后执行加加操作（i++），找到第 1 个比基准数大的值，让它与基准值交换；然后继续寻找，直到 i 与 j 相遇时结束，最后基准值所在的位置即 k 的位置，也就是说 k 左边的值均比 k 上的值小，而 k 右边的值都比 k 上的值大。 </p>
<p><strong>详细解读</strong>：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/02e89e211b0345ba917a79e76a1ba532.jpeg" alt="请添加图片描述"></p>
<p><strong>代码</strong>：（Java版）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.l	ength; i++) &#123;</span><br><span class="line">            System.out.println(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] src, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = src[begin];</span><br><span class="line">            <span class="keyword">int</span> i = begin;</span><br><span class="line">            <span class="keyword">int</span> j = end;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; src[j] &gt; key) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    src[i] = src[j];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; src[i] &lt; key) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    src[j] = src[i];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            src[i] = key;</span><br><span class="line">            quickSort(src, begin, i - <span class="number">1</span>);</span><br><span class="line">            quickSort(src, i + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆排序："><a href="#堆排序：" class="headerlink" title="堆排序："></a>堆排序：</h4><p><strong>核心思想</strong>：</p>
<p>​        堆排序中的“堆”的含义是完全二叉树。算法的具体操作步骤分为4步：</p>
<ol>
<li>先将无序序列画成一个完全二叉树的形式</li>
<li>再自底向上，自右向左对完全二叉树中的元素进行比较得到大根堆或小根堆</li>
<li>然后将完全二叉树的根节点与堆中最右下角的元素互换，互换之后根节点脱落，从此此根节点不再参与比较，而是等待之后的根节点相继脱落一起形成有序区。</li>
<li>之后一种重复2,3步便可得到有序区（有序序列）。</li>
</ol>
<p>这里说一下什么是<strong>完全二叉树</strong>，同时也区分一下完全二叉树与<strong>满二叉树</strong>的区别</p>
<p>先看图：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Center.png" alt="img"></p>
<p><strong>完全二叉树</strong>：设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，<br>第 h 层所有的结点都连续集中在最左边（例如如果在上图的完全二叉树的g结点接一个k结点，则这个数便不再是完全二叉树）</p>
<p><strong>满二叉树</strong>：深度为k且有2^k-1个结点的二叉树称为满二叉树</p>
<p><strong>详细解读</strong>：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/600e3b661578adf7901533bf5cf43a5b.gif" alt="img"></p>
<p><strong>代码</strong>：（C++）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="keyword">int</span> dad = start;</span><br><span class="line">    <span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//若子节点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(*arr);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<p>​        堆是一种很好做调整的结构，在算法题里面使用频度很高。常用于想知道最大值或最小值的情况，比如优先级队列，作业调度等场景。堆排序的时间性能是O(logn) </p>
<h4 id="折半查找："><a href="#折半查找：" class="headerlink" title="折半查找："></a>折半查找：</h4><p><strong>核心思想</strong>：</p>
<p>​        在一个有序表中，每次取目标值与序列中间的值进行比较。若目标值等于值，则查找成功，返回此值的位置；若目标值大于此值，则说明目标值在该查找表的右半区，此时我们往右半区进行查找；若目标值小于此值，则说明目标值在该查找表的右左半区此时我们往左半区进行查找。如此往复，直至查找成功；若无和目标值相等的记录数，则查无此值。</p>
<p><strong>详细解读</strong>：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/e570934d48f84a51b71794961445e188.jpeg" alt="img"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找,又称为二分查找 ,条件保证要好排序的，不适合应用在频繁的插入操作，因为会打乱顺序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low,high,mid;</span><br><span class="line">    low = <span class="number">0</span>;    <span class="comment">//定义最低下标为记录首位</span></span><br><span class="line">    high = n;   <span class="comment">//记录最高下标为记录末位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;<span class="comment">//最高位下标调小 一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>; <span class="comment">//最低下标调整到中位下标大一位</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//代表就是次位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//没有找到返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需求要查找8, 如果用传统的方式 要查找8次才能得出</span></span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//下标</span></span><br><span class="line">    index = Binary_Search(a, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了,index为:%d&quot;</span>,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：</p>
<pre><code>     二分查找有个很重要的特点，就是不会查找数列的全部元素，而查找的数据量其实正好符合元素的对数，正常情况下每次查找的元素都在一半一半地减少。所以二分查找的[时间复杂度](http://data.biancheng.net/view/2.html)为 `O(log2n)` 是毫无疑问的。当然，最好的情况是只查找一次就能找到，但是在最坏和一般情况下的确要比顺序查找好了很多。 
</code></pre>
<h4 id="二叉查找树（二叉搜索树）："><a href="#二叉查找树（二叉搜索树）：" class="headerlink" title="二叉查找树（二叉搜索树）："></a>二叉查找树（二叉搜索树）：</h4><p><strong>核心思想</strong>：</p>
<p>​            左右子树与根节点的关系（左子树比根节点都小，右子树比根节点都大）</p>
<p><strong>详细解读</strong>：<img src="https://pic3.zhimg.com/v2-a979f7099bf4d4d62ad2ab3ef8c95baa_b.webp" alt="动图"></p>
<p>在BST中搜索一个值是非常简单和高效的。</p>
<p><img src="https://pic2.zhimg.com/80/v2-b45aa1eee3d524e00d4207f81fcadb19_720w.jpg" alt="img"></p>
<p>看上面的树，假设要搜索7这个节点。首先从Root节点出发，我们知道7大于3，所以会走到右子树6，然后因为7也大于6，所以会继续往右子树走，到了9，因为7小于9，所以会向左子树走，走到7，发现7等于7，所以找到要搜索的节点。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里先定义出节点的结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = _data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二叉搜索树结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个函数是 private 的，递归调用，插入节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">RecursionInsert</span><span class="params">(Node node, <span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data &lt; node.data)</span><br><span class="line">        &#123;</span><br><span class="line">            node.left = RecursionInsert(node.left, data);</span><br><span class="line">            node.left.parent = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; node.data)</span><br><span class="line">        &#123;</span><br><span class="line">            node.right = RecursionInsert(node.right, data);</span><br><span class="line">            node.right.parent = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外开放的 插入 接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = RecursionInsert(root, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RecursionInsert(root, data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按层序打印二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line">        q.Enqueue(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node currNode = q.Dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currNode.left != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.Enqueue(currNode.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currNode.right != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.Enqueue(currNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 括号里面是父节点的值</span></span><br><span class="line">            string msg = string.Format(<span class="string">&quot;&#123;0&#125;(&#123;1&#125;)&quot;</span>, currNode.data, currNode.parent != <span class="keyword">null</span> ? currNode.parent.data.ToString() : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">            Debug.Log(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个二叉搜索树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* Let us create following BST</span></span><br><span class="line"><span class="comment">          50</span></span><br><span class="line"><span class="comment">       /     \</span></span><br><span class="line"><span class="comment">      30      70</span></span><br><span class="line"><span class="comment">     /  \    /  \</span></span><br><span class="line"><span class="comment">   20   40  60   80 */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BST bst = <span class="keyword">new</span> BST();</span><br><span class="line">        bst.Insert(<span class="number">50</span>);</span><br><span class="line">        bst.Insert(<span class="number">30</span>);</span><br><span class="line">        bst.Insert(<span class="number">20</span>);</span><br><span class="line">        bst.Insert(<span class="number">40</span>);</span><br><span class="line">        bst.Insert(<span class="number">70</span>);</span><br><span class="line">        bst.Insert(<span class="number">60</span>);</span><br><span class="line">        bst.Insert(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        bst.LevelOrderTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong></p>
<p> 二叉查找树查找成功的平均查找长度为: ASL = [ (n+1)/n] * log2 (n+1) - 1 [公式1] 其时间复杂度是: <strong>O (log2 (n))</strong> </p>
<h4 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h4> <HR> 

<p><strong>核心思想</strong>：</p>
<p>打扑克＋遍历，打过扑克的朋友对于理解这个排序应该是手到擒来的，我们在摸牌阶段要不断调整牌的顺序，每次摸一张牌查到原来序列当中，其操作流程就是与每一张牌比大小然后放在比它大的牌前面。</p>
<p><strong>详细解读</strong>：<img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="img"></p>
<p><strong>代码</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> key=arr[i];</span><br><span class="line">                <span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>]=key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：</p>
<p> 插入排序的时间复杂度为O(n^2) </p>
<h2 id="动态规划法与贪心法"><a href="#动态规划法与贪心法" class="headerlink" title="动态规划法与贪心法"></a>动态规划法与贪心法</h2> <HR> 

<h3 id="基本思路：-1"><a href="#基本思路：-1" class="headerlink" title="基本思路："></a>基本思路：</h3><p><strong>动态规划法：</strong></p>
<ol>
<li><p>划分子问题</p>
<p>将原问题分解为若干个子问题，并且子问题之间具有重叠关系（交集）</p>
</li>
<li><p>确定动态规划函数</p>
<p>根据子问题之间的重叠关系，找出满足子问题的递推关系式（即动态规划函数），此乃动态规划法之关键，<strong>找递归关系式往往需要自顶向下</strong></p>
</li>
<li><p>填写表格</p>
<p>以自底向上的方式计算各个子问题的解并填表，实现动态规划过程</p>
</li>
</ol>
<p><strong>贪心法：</strong>其核心便是四个字“目光短浅”，即在解决问题时，只根据当前已有的信息做出最优选择，而不管将来有什么选择，因此其算法希望通过局部最优的选择达到全局最优的选择 。</p>
<h3 id="同与异：-1"><a href="#同与异：-1" class="headerlink" title="同与异："></a>同与异：</h3><p><strong>同：</strong>要求原问题必须有最优子结构。</p>
<p><strong>异：</strong>贪心法的计算方式“自顶向下”，但并不等待子问题求解完毕后再选择使用哪一        个，而是通过一种策略直接选择一个子问题去求解，没被选择的子问题直接抛        弃。这种所谓“最优选择”的正确性需要用归纳法证明。而动态规划不管是采用        自底向上还是自顶向下的计算方式，都是从边界开始向上得到目标问题的解        （即考虑所有子问题）。 </p>
<p><strong>贪心：</strong>壮士断腕的决策，只要选择，绝不后悔。</p>
<p><strong>动态规划：</strong>要看哪个选择笑到最后，暂时领先说明不了问题。</p>
<h3 id="适用范围：-1"><a href="#适用范围：-1" class="headerlink" title="适用范围："></a>适用范围：</h3><p> <strong>动态规划：</strong>多用来解决多阶段决策最优化（最值与优化）问题。</p>
<p><strong>贪心法：</strong>求解最优化问题，而且对于许多问题都能都到整体最优解，即使不能得到整体最优解，通常也是最优解的很好近似。</p>
<h3 id="应用：-1"><a href="#应用：-1" class="headerlink" title="应用："></a>应用：</h3><h5 id="多段图的最短路径问题："><a href="#多段图的最短路径问题：" class="headerlink" title="多段图的最短路径问题："></a>多段图的最短路径问题：</h5><p>​    首先它是个最短路径问题，其次其中的多段的意思，是将图在先不考虑边的情况下，将顶点们分成几个部分。<img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/513e760016e04b3197b876481556c2e7.png" alt="请添加图片描述"></p>
<p>如上图所示将图分为了五个部分，也就是分成了5段，分成多个段的目的其实与动态规划解决问题的特性——<strong>多阶段</strong>是契合的。</p>
<p><strong>核心思想</strong>：</p>
<p> 我们可以把情况从特殊推广到一般情况，设 Cuv 为多段图有向边 &lt;u,v&gt; 的权值，源点 s 到终点 v 的最短路径长为 d(s,v)，终点为 t，则可以得到该问题的状态转移方程为：</p>
<p> <img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/47703228cdade4e783e22e86c2aa7fa6-170565811615810.png" alt="img"></p>
<p><strong>详细解读</strong>：</p>
<p>以上为理论解释，但是不够直观，接下来我用通俗易懂的方式解释一下：</p>
<p>先解释几个定义，以便我们叙述</p>
<p>d(1,6):从0到6的最短路径，换个角度看我们可以叫他：非直接路径</p>
<p>c(1,2):从1到2的路径，例如c(2,5)=9，同上我们可以叫他：直接路径</p>
<p><strong>先说一个结论：直接路径是确定的，非直接路径是需要求最小值的。</strong></p>
<p>我们用图中一个应用来解释，比如说我们现在要从1走到8，求最短路径d(1,8)，那么应该怎么求呢？首先要考虑的一个问题是既然我们要走到8，那哪些点可以直接到8呢？站在8的位置一看，哦！5、6、7这三个点可以到8，因此确定的是c(5,8)=5、c(6,8)=8、c(7,8)=6，此时从1走到8有三种情况</p>
<ul>
<li>1——5——8</li>
<li>1——6——8</li>
<li>1——7——8</li>
</ul>
<p>因此只要我们知道d(1,5)、d(1,6)、d(1,7)便可以用**d(1,5)+c(5,8)**求出1——5——8，剩下两个以此类推，那么接下来的问题就是求d(1,5)了，这显然这跟我们正在求的d(1,8)本质是一样的。那接下来就是分别站在5,6,7的位置重复这一流程。</p>
<p>最后在分别求出d(1,5)+c(5,8)以及其他两个之后，比较三者取最值即可。</p>
<p>可以画一个树来表示整个过程:</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/f5891b2bdddc432fa7f7a950a8f266a6.png" alt="img"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 0xffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//动态规划求最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp_path</span><span class="params">(<span class="keyword">int</span> c[][<span class="number">100</span>], <span class="keyword">int</span> *cost, <span class="keyword">int</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入顶点个数和边个数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//初始化代价矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            c[i][j] = Max;</span><br><span class="line">    <span class="comment">//输入代价矩阵</span></span><br><span class="line">    <span class="keyword">int</span> u, v, s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; s;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;v&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">        c[u][v] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cost[i]=Max;</span><br><span class="line">    path[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    cost[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cost[j] &gt; cost[i] + c[i][j]) &#123;</span><br><span class="line">                path[j] = i;</span><br><span class="line">                cost[j] = cost[i] + c[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cost[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span> i=path[n<span class="number">-1</span>];</span><br><span class="line">    cout&lt;&lt;path[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">while</span>(path[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;path[i]&lt;&lt;endl;</span><br><span class="line">        i=path[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">100</span>][<span class="number">100</span>], cost[<span class="number">100</span>], path[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">dp_path</span>(c, cost, path);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：</p>
<p>此算法的时间复杂度主要由两部分组成：第一部分是依次计算从源点到各个顶点的最短路径长度，由两层嵌套的循环组成，外层循环执行 n-1 次，内层循环对所有入边进行计算，并且在所有循环中，每条入边只计算一次。若假定图的边数为 m，则时间性能是 O(m)。第二部分是输出最短路径经过的顶点，设多段图划分为 k 段，其时间性能是 O(k)。综上所述，**时间复杂度为 O(m+k)**。 </p>
<p>许多导航和地图软件，只需要输入起始点和目的点，系统便会给出到达目的地的最短路线，这是多段图最短路径问题的典型应用。</p>
<h5 id="01背包问题："><a href="#01背包问题：" class="headerlink" title="01背包问题："></a>01背包问题：</h5><h5 id="最长公共子序列问题："><a href="#最长公共子序列问题：" class="headerlink" title="最长公共子序列问题："></a>最长公共子序列问题：</h5><p>​    公共就是你有我也有，子序列就是字符串中<strong>不一定连续但先后顺序一致</strong>的n个字符， 例如字符串abcbca，aca、abba就属于它的子序列；（这里要区别一下子串， <strong>子串：</strong>指的是字符串中<strong>连续</strong>的n个字符 ，例如字符串qwerabc中，qwe、rab、wera都属于它的子串）那么连起来就是：你我都有的最长的不一定连续但先后顺序一致字符串。</p>
<p>例如： 序列1,3,5,4,2,6,8,7和序列1,4,8,6,7,5，它们的最长公共子序列有1,4,8,7和1,4,6,7 ， 其长度是4， 并且通过这个应用我们可以发现，最长公共子序列不一定唯一。</p>
<p><strong>核心思想</strong>：</p>
<p>首先我们想解决这个问题，下意识想到的就是无脑遍历啦，但是遍历的时间复杂度太高了，所以不推荐，采用动态规划做有几个点比较重要，那就是动态规划函数的理解</p>
<p><strong>详细解读</strong>：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/a54e2e4705604b258e44e6e30c747572.jpeg" alt="请添加图片描述"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">100</span>][<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> judge[<span class="number">100</span>][<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_LCS</span><span class="params">(<span class="keyword">int</span> judge[][<span class="number">100</span>], string x,<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string a, b;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">	<span class="keyword">int</span> m = a.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">int</span> n = b.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				judge[i][j] = <span class="number">1</span>;	<span class="comment">//最后一个字符相等，则</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(table[i - <span class="number">1</span>][j] &gt;= table[i][j - <span class="number">1</span>])		<span class="comment">//最后一个字符不相等，且上方大于左方</span></span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i - <span class="number">1</span>][j];</span><br><span class="line">				judge[i][j] = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">                <span class="comment">//最后一个字符不相等，且上方小于左方</span></span><br><span class="line">			&#123;</span><br><span class="line">				table[i][j] = table[i][j - <span class="number">1</span>];</span><br><span class="line">				judge[i][j] = <span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; table[m][n] &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">print_LCS</span>(judge, a, m, n);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_LCS</span><span class="params">(<span class="keyword">int</span> judge[][<span class="number">100</span>],string a,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//x,y,分别为两段长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (judge[x][y] == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">print_LCS</span>(judge, a, x<span class="number">-1</span>, y<span class="number">-1</span>);</span><br><span class="line">		cout &lt;&lt; a[x<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (judge[x][y] == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">print_LCS</span>(judge, a, x - <span class="number">1</span>, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (judge[x][y] == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">print_LCS</span>(judge, a, x, y - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：</p>
<p>此算法时间复杂度为O(n×m)，其中n为第一个字符串的个数，m为第二个字符串的个数。</p>
<p> 最长公共子序列是一个十分实用的问题，它可以描述两段文字之间的“相似度”，即它们的雷同程度，从而能够用来辨别抄袭。对一段文字进行修改之后，计算改动前后文字的最长公共子序列，将除此子序列外的部分提取出来，这种方法判断修改的部分，往往十分准确。简而言之，百度知道、百度百科都用得上。如判断S1和S2相似的办法是找出他们的公共子序列S3，S3以相同的顺序在S1和S2中出现，但是不必要连续。S3越长，S1和S3就越相似。 </p>
<p><strong>两个字符串A与B，如果他们最后一个字符是相同的，则此时的最长公共子序列是去掉它们相同的那个，用之前的最长公共子序列长度+1则是，此时的最长公共子序列的长度；如果他们最后一个字符不相同，则此时用A去掉最后一个字符和B求最长公共子序列，再用B去掉最后一个字符和A求最长公共子序列，将两个最长公共子序列作比较，哪个长取哪个。</strong></p>
<h4 id="最小生成树问题："><a href="#最小生成树问题：" class="headerlink" title="最小生成树问题："></a>最小生成树问题：</h4><p> 对于含有 n 个顶点的连通图来说可能包含有多种生成树，例如图所示 ：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9c018de1483587f1c5b5500a67aae2f6.png" alt="img"></p>
<p> 在给定一张无向图，如果在它的子图中，任意两个顶点都是互相连通，并且是一个树结构，那么这棵树叫做生成树。当连接顶点之间的图有权重时，权重之和最小的树结构为最小生成树！ </p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/96f0b8a7ed8780a5914947a76bd8354e.png" alt="img"></p>
<p> 在实际中，这种算法的应用非常广泛，比如我们需要在n个城市铺设电缆，则需要n-1条通信线路，那么我们如何铺设可以使得电缆最短呢？最小生成树就是为了解决这个问题而诞生的！ </p>
<p><strong>核心思想：</strong></p>
<ol>
<li><p><strong>Prim算法（从点出发）</strong></p>
<p>任选一个顶点，并以此建立生成树的根节点，每一步的贪心选择是<strong>把不再生成树中的最近顶点</strong>添加到生成树中。</p>
</li>
<li><p><strong>Kruskal算法（从边出发）</strong></p>
<p>将无向连通图去边，然后在边的权值中选择最小的，然后将这条边的两个顶点相连，再寻找权值最小的，然后将对应顶点相连，直到形成一个生成树（没有闭环）。</p>
</li>
</ol>
<p><strong>详细解读</strong>：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7905f53fc82548ab813efa3af2978989.jpeg" alt="请添加图片描述"></p>
<p>代码：****</p>
<p>Prim算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 6    <span class="comment">// 记录图中顶点的个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> <span class="literal">false</span>, <span class="literal">true</span> &#125; <span class="keyword">bool</span>;</span><br><span class="line"><span class="comment">//查找权值最小的、尚未被选择的顶点，key 数组记录了各顶点之间的权值数据，visited数组记录着各个顶点是否已经被选择的信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_Key</span><span class="params">(<span class="keyword">int</span> key[], <span class="keyword">bool</span> visited[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">2147483647</span>, min_index;  <span class="comment">//遍历 key 数组使用，min 记录最小的权值，min_index 记录最小权值关联的顶点</span></span><br><span class="line">    <span class="comment">//遍历 key 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">        <span class="comment">//如果当前顶点为被选择，且对应的权值小于 min 值</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v] == <span class="literal">false</span> &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">            <span class="comment">//更新  min 的值并记录该顶点的位置</span></span><br><span class="line">            min = key[v];</span><br><span class="line">            min_index = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最小权值的顶点的位置</span></span><br><span class="line">    <span class="keyword">return</span> min_index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_MST</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> cost[V][V])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minCost = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小生成树为：\n&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历 parent 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; V; i++) &#123;</span><br><span class="line">        <span class="comment">//parent 数组下标值表示各个顶点，各个下标对应的值为该顶点的父节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %d wight:%d\n&quot;</span>, parent[i] + <span class="number">1</span>, i + <span class="number">1</span>, cost[i][parent[i]]);<span class="comment">//由于数组下标从 0 开始，因此输出时各自 +1</span></span><br><span class="line">        <span class="comment">//统计最小生成树的总权值</span></span><br><span class="line">        minCost += cost[i][parent[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总权值为：%d&quot;</span>, minCost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据用户提供了图的信息（存储在 cost 数组中），寻找最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_MST</span><span class="params">(<span class="keyword">int</span> cost[V][V])</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">//key 数组用于记录 B 类顶点到 A 类顶点的权值</span></span><br><span class="line">    <span class="comment">//parent 数组用于记录最小生成树中各个顶点父节点的位置，便于最终生成最小生成树</span></span><br><span class="line">    <span class="comment">//visited 数组用于记录各个顶点属于 A 类还是 B 类</span></span><br><span class="line">    <span class="keyword">int</span> parent[V], key[V];</span><br><span class="line">    <span class="keyword">bool</span> visited[V];</span><br><span class="line">    <span class="comment">// 初始化 3 个数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">        key[i] = <span class="number">2147483647</span>;    <span class="comment">// 将 key 数组各个位置设置为无限大的数</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;     <span class="comment">// 所有的顶点全部属于 B 类</span></span><br><span class="line">        parent[i] = <span class="number">-1</span>;         <span class="comment">// 所有顶点都没有父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择 key 数组中第一个顶点，开始寻找最小生成树</span></span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 该顶点对应的权值设为 0</span></span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 该顶点没有父节点</span></span><br><span class="line">    <span class="comment">// 对于 V 个顶点的图，最需选择 V-1 条路径，即可构成最小生成树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; V - <span class="number">1</span>; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从 key 数组中找到权值最小的顶点所在的位置</span></span><br><span class="line">        <span class="keyword">int</span> u = min_Key(key, visited);</span><br><span class="line">        <span class="comment">// 该顶点划分到 A 类</span></span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 由于新顶点加入 A 类，因此需要更新 key 数组中的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果类 B 中存在到下标为 u 的顶点的权值比 key 数组中记录的权值还小，表明新顶点的加入，使得类 B 到类 A 顶点的权值有了更好的选择</span></span><br><span class="line">            <span class="keyword">if</span> (cost[u][v] != <span class="number">0</span> &amp;&amp; visited[v] == <span class="literal">false</span> &amp;&amp; cost[u][v] &lt; key[v])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新 parent 数组记录的各个顶点父节点的信息</span></span><br><span class="line">                parent[v] = u;</span><br><span class="line">                <span class="comment">// 更新 key 数组</span></span><br><span class="line">                key[v] = cost[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据 parent 记录的各个顶点父节点的信息，输出寻找到的最小生成树</span></span><br><span class="line">    print_MST(parent, cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1, p2;</span><br><span class="line">    <span class="keyword">int</span> wight;</span><br><span class="line">    <span class="keyword">int</span> cost[V][V] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入图（顶点到顶点的路径和权值)：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p1, &amp;p2);</span><br><span class="line">        <span class="comment">//如果用户输入 -1 -1，表示输入结束</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="number">-1</span> &amp;&amp; p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wight);</span><br><span class="line">        cost[p1 - <span class="number">1</span>][p2 - <span class="number">1</span>] = wight;</span><br><span class="line">        cost[p2 - <span class="number">1</span>][p1 - <span class="number">1</span>] = wight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据用户输入的图的信息，寻找最小生成树</span></span><br><span class="line">    find_MST(cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kruskal算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 9   <span class="comment">// 图中边的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 6   <span class="comment">// 图中顶点的数量</span></span></span><br><span class="line"><span class="comment">//构建表示边的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="comment">//一条边有 2 个顶点</span></span><br><span class="line">    <span class="keyword">int</span> initial;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="comment">//边的权值</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//qsort排序函数中使用，使edges结构体中的边按照权值大小升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  ((struct edge*)a)-&gt;weight - ((struct edge*)b)-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//克鲁斯卡尔算法寻找最小生成树，edges 存储用户输入的图的各个边，minTree 用于记录组成最小生成树的各个边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal_MinTree</span><span class="params">(struct edge edges[], struct edge minTree[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, initial, end, elem, k;</span><br><span class="line">    <span class="comment">//每个顶点配置一个标记值</span></span><br><span class="line">    <span class="keyword">int</span> assists[P];</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始状态下，每个顶点的标记都不相同</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; P; i++) &#123;</span><br><span class="line">        assists[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据权值，对所有边进行升序排序</span></span><br><span class="line">    qsort(edges, N, <span class="keyword">sizeof</span>(edges[<span class="number">0</span>]), cmp);</span><br><span class="line">    <span class="comment">//遍历所有的边</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">//找到当前边的两个顶点在 assists 数组中的位置下标</span></span><br><span class="line">        initial = edges[i].initial - <span class="number">1</span>;</span><br><span class="line">        end = edges[i].end - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果顶点位置存在且顶点的标记不同，说明不在一个集合中，不会产生回路</span></span><br><span class="line">        <span class="keyword">if</span> (assists[initial] != assists[end]) &#123;</span><br><span class="line">            <span class="comment">//记录该边，作为最小生成树的组成部分</span></span><br><span class="line">            minTree[num] = edges[i];</span><br><span class="line">            <span class="comment">//计数+1</span></span><br><span class="line">            num++;</span><br><span class="line">            elem = assists[end];</span><br><span class="line">            <span class="comment">//将新加入生成树的顶点标记全部改为一样的</span></span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; P; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (assists[k] == elem) &#123;</span><br><span class="line">                    assists[k] = assists[initial];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果选择的边的数量和顶点数相差1，证明最小生成树已经形成，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (num == P - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(struct edge minTree[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cost = <span class="number">0</span>, i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小生成树为:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; P - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-%d  权值：%d\n&quot;</span>, minTree[i].initial, minTree[i].end, minTree[i].weight);</span><br><span class="line">        cost += minTree[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总权值为：%d&quot;</span>, cost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">edges</span>[<span class="title">N</span>], <span class="title">minTree</span>[<span class="title">P</span> - 1];</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;edges[i].initial, &amp;edges[i].end, &amp;edges[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    kruskal_MinTree(edges, minTree);</span><br><span class="line">    display(minTree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：</p>
<p> 由于Kruksal算法是对边进行操作，先取出边，然后判断边的两个节点，这样的话，如果一个图结构非常的稠密，那么Kruksal算法就比较慢了，而Prim算法只是对节点进行遍历，并使用set进行标记，因此会相对于Kruksal算法，在稠密图方面好很多，因此<strong>Kruksal算法常用于稀疏图，而Prim算法常用于稠密图！</strong> </p>
<p> 普里姆算法该算法运行的时间复杂度为：<code>O(n^2)</code>，</p>
<h1 id="基于搜索的算法设计技术"><a href="#基于搜索的算法设计技术" class="headerlink" title="基于搜索的算法设计技术"></a>基于搜索的算法设计技术</h1><h2 id="回溯法与分支限界法"><a href="#回溯法与分支限界法" class="headerlink" title="回溯法与分支限界法"></a>回溯法与分支限界法</h2><h3 id="基本思路：-2"><a href="#基本思路：-2" class="headerlink" title="基本思路："></a>基本思路：</h3><p>在这之前我们先看一下解空间树这个概念，因为这两种算法都用到了解空间树</p>
<p>一般来说，当一个问题有多种解，我们表示多种解的时，便可以用到解空间树，说彻底一点其实就是这个问题的解有哪几种情况。</p>
<p><img src="https://pic2.zhimg.com/v2-9ff7e1d3a9f80e1309d07aa08fc3d9b9_b.jpg" alt="查看源图像"></p>
<p>例如上图中，黑白双方各下一子之后，该黑方走棋，此时便有三种情况，move1，move2，move3,，而之后又该白方走棋，白方又有若干种情况，这便构成了下棋这个问题的解空间树。</p>
<p><strong>回溯法：</strong></p>
<p>​         把问题的解用解空间树的结构表示，然后使用<strong>深度优先搜索策略</strong>进行遍历，遍历的过程 ：首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用<strong>约束条件</strong>判断该节点是否可行（即能得到问题的解）。如果不可行，则对该节点的子树进行<strong>剪枝</strong>（ 为了避免无效的搜索 ），然后逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>
<p><strong>分支限界法：</strong></p>
<p>​         把问题的解用解空间树的结构表示， 按<strong>广度优先搜索策略</strong>搜索问题的解空间树，在搜索过程中，对待处理的节点根据限界函数估算目标函数的可能取值，从中选取使目标函数取得极值（极大或极小）的结点优先进行广度优先搜索，从而<strong>不断调整搜索方向</strong>（跳跃式），尽快找到问题的解。分支限界法适合求解最优化问题。</p>
<p>​        用分支限界法解决问题，我们一般有五个步骤：</p>
<ol>
<li>确定限界函数</li>
<li>确定上下界</li>
<li> 利用广度优先扩展结点（把一个结点的所有子结点扩展完）</li>
<li>根据限界函数评估每一个结点</li>
<li>结点评估值属于上下界，则加入PT表，不属于则剪枝</li>
<li>根据所求问题，比较这一层PT表中的结点哪个最大，或者哪个最小来选择结点进行扩展，为什么是这一层呢？因为使用的是广度优先搜索策略</li>
</ol>
<h3 id="同与异：-2"><a href="#同与异：-2" class="headerlink" title="同与异："></a>同与异：</h3><p>同：</p>
<ol>
<li>都是基于<strong>搜索</strong>的算法</li>
<li>都需要在<strong>解空间树</strong>中进行搜索</li>
<li>在搜索的过程中都</li>
<li>需要进行<strong>剪枝</strong></li>
</ol>
<p>异：</p>
<ul>
<li>回溯法用<strong>深度优先算法</strong>（DFS），分支限界法用<strong>广度优先算法</strong>（BFS）。</li>
<li>回溯法的整个搜索过程是<strong>机械</strong>的进行，而分支限界法对节点的处理是<strong>跳跃式</strong>的，因此需要维护一个待处理结点表PT，而PT表的逻辑结构可以用<strong>堆</strong>或<strong>优先队列</strong>的形式存储。</li>
</ul>
<h3 id="适用范围：-2"><a href="#适用范围：-2" class="headerlink" title="适用范围："></a>适用范围：</h3><p>回溯法：找到一组可行解，适用于求解组合数较大的问题</p>
<p>分支限界法：找到一组最优解，适合解决最优化问题。</p>
<h3 id="应用：-2"><a href="#应用：-2" class="headerlink" title="应用："></a>应用：</h3><p>回溯法和分支限界法实际上都属于蛮力穷举法，在最坏情况下，时间复杂度肯定为指数阶，但是因为其剪枝的特性，只要设计好了<strong>约束条件</strong>和<strong>限界函数</strong>，便可以得到不错的时间性能。</p>
<h5 id="图着色问题："><a href="#图着色问题：" class="headerlink" title="图着色问题："></a>图着色问题：</h5><p>顾名思义对图中的顶点进行着色的问题，有两个条件，一：图是无向连通图，二：着色时使任意两个相邻顶点着色不同，最后求顶点的涂色情况。</p>
<h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h5><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<p><strong>详细解读</strong></p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/49df603d5d1c428d8f8a01fc72c50fb3.jpeg" alt="请添加图片描述"></p>
<p>1、2、3代表颜色，A\B\C\D\E代表无向连通图中的顶点，1~14代表树中结点的编号。</p>
<p>画出解空间树的过程，或者说解空间树表示的意义就是：在模拟我们对顶点着色的过程，着色必定要一个一个尝试，符合条件保留，不符合剪枝，如果所有颜色都尝试过之后，依旧不符合条件，则回溯到当前结点的父节点处，再进行尝试。</p>
<p><strong>总结</strong></p>
<p>用m种颜色为一个具有n个顶点的无向图着色，共有<code>m^n</code>种可能的着色组合，因此最坏情况下的时间复杂度为O(m^n).</p>
<h5 id="哈密顿回路问题"><a href="#哈密顿回路问题" class="headerlink" title="哈密顿回路问题"></a>哈密顿回路问题</h5><p><strong>核心思想</strong></p>
<p><strong>详细解读</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arc[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hamiton</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, k;</span><br><span class="line">	<span class="keyword">int</span> visited[<span class="number">10</span>];		<span class="comment">//假设图中最多有10个顶点</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		x[i] = <span class="number">0</span>;			<span class="comment">//初始化回路的顶点数组和标志数组</span></span><br><span class="line">		visited[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">0</span>;		<span class="comment">//从顶点0出发</span></span><br><span class="line">	visited[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (k &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">		x[k] = x[k] + <span class="number">1</span>;	<span class="comment">//搜索下一个顶点</span></span><br><span class="line">		<span class="keyword">while</span> (x[k] &lt; n) &#123;</span><br><span class="line">			<span class="keyword">if</span> (visited[x[k]] == <span class="number">0</span> &amp;&amp; arc[x[k - <span class="number">1</span>]][x[k]] == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				x[k] = x[k] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (x[k] &lt; n &amp;&amp; k == n - <span class="number">1</span> &amp;&amp; arc[x[k]][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">				cout &lt;&lt; x[k] + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;		<span class="comment">//输出顶点的编号，从1开始</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x[k] &lt; n &amp;&amp; k &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">			visited[x[k]] = <span class="number">1</span>;</span><br><span class="line">			k = k + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;							<span class="comment">//回溯</span></span><br><span class="line">			visited[x[k]] = <span class="number">0</span>;</span><br><span class="line">			x[k] = <span class="number">0</span>;</span><br><span class="line">			k = k - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>总结</strong></p>
<h5 id="TSP问题："><a href="#TSP问题：" class="headerlink" title="TSP问题："></a>TSP问题：</h5><p>  TSP，即旅行商问题，又称TSP问题（Traveling Salesman Problem）， 假设有一个旅行商人要拜访N个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。TSP问题是一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/NPC/658479">NPC</a>问题。 </p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/20190715190545629.png" alt="img"></p>
<p><strong>核心思想</strong></p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/20190715190807263.png" alt="在这里插入图片描述"></p>
<p>很明显，这表达太抽象了！</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/eed09467e0c84e1fa62fac6cb963706f.jpeg" alt="img"></p>
<p><strong>详细解读</strong>：</p>
<p>可以看看这个视频吧，说的比较清楚，可能有点啰嗦了。。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JW4y1k7nN">TSP问题——分支限界法</a></p>
<p>完整流程就是，</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] visp;<span class="comment">//标记哪些点走了</span></span><br><span class="line">    <span class="keyword">int</span> st;<span class="comment">//起点</span></span><br><span class="line">    <span class="keyword">int</span> ed;<span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">int</span> k;<span class="comment">//走过的点数</span></span><br><span class="line">    <span class="keyword">int</span> sumv;<span class="comment">//经过路径的距离</span></span><br><span class="line">    <span class="keyword">int</span> lb;<span class="comment">//目标函数的值</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; map_edge=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//记录已经加入的边</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        Node node=(Node) o;</span><br><span class="line">        <span class="keyword">if</span>(node.lb&lt;<span class="keyword">this</span>.lb)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node.lb&gt;<span class="keyword">this</span>.lb)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BBTSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] mp;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> up=<span class="number">16</span>;<span class="comment">//路径总和上界,第一次为无穷大，后面取每个可行分支的最小值</span></span><br><span class="line">    <span class="keyword">int</span> low;<span class="comment">//路径和最小值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Point&gt; points;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Node&gt; q=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Node&gt; q_last=<span class="keyword">new</span> PriorityQueue&lt;&gt;();<span class="comment">//记录每条路径的最后一个节点，以及对应的路径值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BBTSP</span><span class="params">(<span class="keyword">int</span>[][] mp,List&lt;Point&gt; points)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mp=mp;</span><br><span class="line">        points=<span class="keyword">this</span>.points;</span><br><span class="line">        n=points.size();</span><br><span class="line">        sum_origin=points.get(<span class="number">0</span>).getStock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BBTSP</span><span class="params">(<span class="keyword">int</span>[][] mp)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.mp=mp;</span><br><span class="line">        n=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_low</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/*通过排序求两个最小值*/</span></span><br><span class="line">            <span class="comment">//double min1=Double.MAX_VALUE,min2=Double.MAX_VALUE;</span></span><br><span class="line">            <span class="keyword">double</span>[] tmpA=<span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//if(i==j) continue;</span></span><br><span class="line">                tmpA[j]=mp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">           Arrays.sort(tmpA);<span class="comment">//对临时的数组进行排序</span></span><br><span class="line">            low+=tmpA[<span class="number">1</span>]+tmpA[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        low=low%<span class="number">2</span>==<span class="number">0</span>?low/<span class="number">2</span>:(low/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get_lb</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=p.sumv*<span class="number">2</span>;<span class="comment">//路径上的点的距离</span></span><br><span class="line">        <span class="keyword">double</span> min1=Double.MAX_VALUE,min2=Double.MAX_VALUE;<span class="comment">//起点和终点连出来的边</span></span><br><span class="line">       <span class="comment">/* System.out.println(&quot;边：&quot;);</span></span><br><span class="line"><span class="comment">        for(Map.Entry&lt;Integer,Integer&gt; entry: p.map_edge.entrySet())</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;start=&quot;+entry.getKey()+&quot;,end=&quot;+entry.getValue());*/</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map=p.map_edge;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">           <span class="comment">// System.out.println(&quot;++++++++++++i=&quot;+i+&quot;+++++++++++++++++++&quot;);</span></span><br><span class="line">            <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>;<span class="comment">//该点为出点</span></span><br><span class="line">            <span class="keyword">boolean</span> flag2 = <span class="keyword">false</span>;<span class="comment">//该点为入点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> start = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(i)) &#123;</span><br><span class="line">                flag1 = <span class="keyword">true</span>;</span><br><span class="line">                end = map.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsValue(i)) &#123;</span><br><span class="line">                flag2 = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())</span><br><span class="line">                    <span class="keyword">if</span>(entry.getValue()==i) start=entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag1 &amp;&amp; flag2) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (!flag1&amp;&amp;flag2) &#123;<span class="comment">//该点只有入点，没有出点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j || j == start) <span class="keyword">continue</span>;</span><br><span class="line">                    array.add(mp[i][j]);</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;flag1       map[&quot;+i+&quot;]&quot;+&quot;[&quot;+j+&quot;]=&quot;+mp[i][j]);</span></span><br><span class="line">                &#125;</span><br><span class="line">                Collections.sort(array);</span><br><span class="line"></span><br><span class="line">                ret += array.get(<span class="number">0</span>);</span><br><span class="line">               <span class="comment">// System.out.println(&quot;array.get(0)=&quot;+array.get(0)+&quot;,ret=&quot;+ret);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!flag2&amp;&amp;flag1) &#123;</span><br><span class="line">                array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j || j == end) <span class="keyword">continue</span>;</span><br><span class="line">                    array.add(mp[j][i]);</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;flag2       map[&quot;+j+&quot;]&quot;+&quot;[&quot;+i+&quot;]=&quot;+mp[j][i]);</span></span><br><span class="line">                &#125;</span><br><span class="line">                Collections.sort(array);</span><br><span class="line">                ret += array.get(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//System.out.println(&quot;array.get(0)=&quot;+array.get(0)+&quot;,ret=&quot;+ret);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!flag1&amp;&amp;!flag2)&#123;</span><br><span class="line">                array=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                    array.add(mp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                Collections.sort(array);</span><br><span class="line">                ret += array.get(<span class="number">0</span>)+array.get(<span class="number">1</span>);</span><br><span class="line">               <span class="comment">// System.out.println(&quot;array.get(0)=&quot;+array.get(0)+&quot;array.get(1)=&quot;+array.get(1)+&quot;,ret=&quot;+ret);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.ret=&quot;</span>+ret);</span><br><span class="line">        <span class="keyword">return</span> ret%<span class="number">2</span>==<span class="number">0</span>?(ret/<span class="number">2</span>):(ret/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        get_low();</span><br><span class="line">        System.out.println(<span class="string">&quot;low=&quot;</span>+low);</span><br><span class="line">        <span class="comment">/*设置初始点,默认从1开始 */</span></span><br><span class="line">        Node star=<span class="keyword">new</span> Node();</span><br><span class="line">        star.st=<span class="number">0</span>;</span><br><span class="line">        star.ed=<span class="number">0</span>;</span><br><span class="line">        star.k=<span class="number">1</span>;</span><br><span class="line">        star.visp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) star.visp[i]=<span class="number">0</span>;</span><br><span class="line">        star.visp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        star.sumv=<span class="number">0</span>;</span><br><span class="line">        star.lb=low;</span><br><span class="line">        System.out.println(<span class="string">&quot;n=&quot;</span>+n);</span><br><span class="line">        <span class="comment">/*ret为问题的解*/</span></span><br><span class="line">        <span class="keyword">double</span> ret=Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        q.add(star);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Node tmp=q.peek();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!q_last.isEmpty())&#123;</span><br><span class="line">                Node last=q_last.peek();</span><br><span class="line">                <span class="keyword">if</span>(last.lb&lt;=tmp.lb) <span class="keyword">return</span> last;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;输出队列里面的数据&quot;</span>);</span><br><span class="line">            Iterator&lt;Node&gt; it=q.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                Node no=it.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;node.st=&quot;</span>+no.st+<span class="string">&quot;;node.ed=&quot;</span>+no.ed+<span class="string">&quot;;node.sumv=&quot;</span>+no.sumv);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;tmp.st=&quot;</span>+tmp.st+<span class="string">&quot;;tmp.ed=&quot;</span>+tmp.ed+<span class="string">&quot;;tmp.sumv=&quot;</span>+tmp.sumv);</span><br><span class="line">            Map&lt;Integer,Integer&gt; tmp_map=tmp.map_edge;</span><br><span class="line">            q.poll();</span><br><span class="line">            <span class="keyword">if</span>(tmp.k==n-<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;最后一个点&quot;</span>);</span><br><span class="line">            <span class="comment">/*找最后一个没有走的点*/</span></span><br><span class="line">                <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(tmp.visp[i]==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        p=i;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Node next=<span class="keyword">new</span> Node();</span><br><span class="line">                next.visp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">                next.st=tmp.ed;</span><br><span class="line">                next.ed=p;</span><br><span class="line">                <span class="keyword">int</span> ans=tmp.sumv+mp[p][<span class="number">0</span>]+mp[tmp.ed][p];<span class="comment">//最终的最短路径</span></span><br><span class="line">                next.sumv=ans;</span><br><span class="line">                next.k=tmp.k+<span class="number">1</span>;</span><br><span class="line">                next.map_edge.putAll(tmp.map_edge);</span><br><span class="line">                next.map_edge.put(next.st,next.ed);</span><br><span class="line">                next.map_edge.put(next.ed,<span class="number">0</span>);</span><br><span class="line">                next.lb=ans;</span><br><span class="line">                System.out.println(<span class="string">&quot;next.i=&quot;</span>+p+<span class="string">&quot;;next.lib=&quot;</span>+next.lb+<span class="string">&quot;;next.st=&quot;</span>+next.st+<span class="string">&quot;;next.ed=&quot;</span>+next.ed+<span class="string">&quot;;next.sumv=&quot;</span>+next.sumv);</span><br><span class="line">                Node judge = q.peek();</span><br><span class="line">                <span class="comment">/*如果当前的路径和比所有的目标函数值都小则跳出*/</span></span><br><span class="line">                <span class="keyword">if</span>(ans &lt;= judge.lb||judge==<span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//ret=Math.min(ans,ret);</span></span><br><span class="line">                   <span class="comment">// ret_map.put(ans,next);</span></span><br><span class="line">                    <span class="keyword">return</span> next;</span><br><span class="line">                   <span class="comment">// break;</span></span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">/*否则继续求其他可能的路径和，并更新上界*/</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    up = Math.min(up,ans);</span><br><span class="line">                    q_last.add(next);</span><br><span class="line">                   <span class="comment">// ret=Math.min(ret,ans);</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/*当前点可以向下扩展的点入优先级队列*/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp.visp[i]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Node next=<span class="keyword">new</span> Node();</span><br><span class="line">                    next.visp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">                    next.st=tmp.ed;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*更新路径和*/</span></span><br><span class="line">                    <span class="comment">//System.out.println(&quot;tmp.sumv=&quot;+tmp.sumv);</span></span><br><span class="line">                    next.sumv=tmp.sumv+mp[tmp.ed][i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*更新最后一个点*/</span></span><br><span class="line">                    next.ed=i;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*更新顶点数*/</span></span><br><span class="line">                    next.k=tmp.k+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*更新经过的顶点*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) next.visp[j]=tmp.visp[j];</span><br><span class="line">                    next.visp[i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*求目标函数*/</span></span><br><span class="line">                    Map&lt;Integer,Integer&gt; next_map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    next_map.putAll(tmp_map);</span><br><span class="line">                    next_map.put(next.st,next.ed);</span><br><span class="line">                    next.map_edge=next_map;</span><br><span class="line"></span><br><span class="line">                    next.lb=get_lb(next);</span><br><span class="line">                    System.out.println(<span class="string">&quot;sumv=&quot;</span>+next.sumv);</span><br><span class="line">                    System.out.println(<span class="string">&quot;next.i=&quot;</span>+i+<span class="string">&quot;;next.lib=&quot;</span>+next.lb+<span class="string">&quot;;next.st=&quot;</span>+next.st+<span class="string">&quot;;next.ed=&quot;</span>+next.ed+<span class="string">&quot;;next.sumv=&quot;</span>+next.sumv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*如果大于上界就不加入队列*/</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(next.lb&gt;up)&#123;</span><br><span class="line">                        next_map.remove(next.st);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// return ret;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] d=&#123;</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        BBTSP b=<span class="keyword">new</span> BBTSP(d);</span><br><span class="line">        Node node=b.solve();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++输出结果：++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最后遍历的点的信息：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;node.lib=&quot;</span>+node.lb+<span class="string">&quot;;node.st=&quot;</span>+node.st+<span class="string">&quot;;node.ed=&quot;</span>+node.ed+<span class="string">&quot;;node.sumv=&quot;</span>+node.sumv);</span><br><span class="line">        System.out.println(<span class="string">&quot;最短路径为：&quot;</span>+node.lb);</span><br><span class="line">        System.out.println(<span class="string">&quot;构成的边为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry: node.map_edge.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot;  -&gt;  &quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*  Node n1=new Node();</span></span><br><span class="line"><span class="comment">        n1.lb=9;</span></span><br><span class="line"><span class="comment">        Node n2=new Node();</span></span><br><span class="line"><span class="comment">        n2.lb=19;</span></span><br><span class="line"><span class="comment">        Node n3=new Node();</span></span><br><span class="line"><span class="comment">        n3.lb=11;</span></span><br><span class="line"><span class="comment">        Node n4=new Node();</span></span><br><span class="line"><span class="comment">        n4.lb=5;</span></span><br><span class="line"><span class="comment">        Node n5=new Node();</span></span><br><span class="line"><span class="comment">        n5.lb=2;</span></span><br><span class="line"><span class="comment">         PriorityQueue&lt;Node&gt; q1=new PriorityQueue&lt;&gt;();</span></span><br><span class="line"><span class="comment">        q1.add(n1);</span></span><br><span class="line"><span class="comment">        q1.add(n2);</span></span><br><span class="line"><span class="comment">        q1.add(n3);</span></span><br><span class="line"><span class="comment">        q1.add(n4);</span></span><br><span class="line"><span class="comment">        q1.add(n5);</span></span><br><span class="line"><span class="comment">        while(!q1.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">            Node nn=q1.poll();</span></span><br><span class="line"><span class="comment">            System.out.println(nn.lb);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h5> <HR> 
有一个容量为`W`的背包，还有`n`个物体。现在忽略物体实际几何形状，我们认为只要背包的剩余容量大于等于物体体积，那就可以装进背包里。每个物体都有两个属性，即体积`w`和价值`v`。
问：如何向背包装物体才能使背包中物体的总价值最大？ 

<p>背包容量W=10；物品个数n=4</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4fcc79c069754a2d8e851645904db81e.png" alt="img"></p>
<p><strong>核心思想</strong></p>
<p>一般情况下，假设当前已经对前<code>i</code>个物品进行了某种特定的选择，且背包中已装入物品的重量时<code>w</code>，获得的价值是<code>v</code>，计算该节点的目标函数上界的一个简单方法是，将背包中剩余容量全被装入第<code>i+1</code>个物品，并可以将背包装满，于是得到了限界函数：</p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/20190715193441970.png" alt="在这里插入图片描述"></p>
<p><code>W</code>为背包的容量，物品<code>i</code>的重量时<code>wi</code>，其价值为<code>vi</code></p>
<p><strong>详细解读</strong></p>
<p><img src="/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/d01c72e164664626965e761ae3b7a99e.jpeg" alt="img"></p>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">bool</span> bestx[N];</span><br><span class="line"><span class="comment">//定义结点。每个节点来记录当前的解。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cp, rp; <span class="comment">//cp背包的物品总价值，rp剩余物品的总价值</span></span><br><span class="line">    <span class="keyword">int</span> rw; <span class="comment">//剩余容量</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//物品号</span></span><br><span class="line">    <span class="keyword">bool</span> x[N];<span class="comment">//解向量</span></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _cp, <span class="keyword">int</span> _rp, <span class="keyword">int</span> _rw, <span class="keyword">int</span> _id)&#123;</span><br><span class="line">        cp = _cp;</span><br><span class="line">        rp = _rp;</span><br><span class="line">        rw = _rw;</span><br><span class="line">        id = _id;</span><br><span class="line">        <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(x));<span class="comment">//解向量初始化为0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125; goods[N];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> bestp,W,n,sumw,sumv;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  bestp 用来记录最优解。</span></span><br><span class="line"><span class="comment">  W为购物车最大容量。</span></span><br><span class="line"><span class="comment">  n为物品的个数。</span></span><br><span class="line"><span class="comment">  sumw 为所有物品的总重量。</span></span><br><span class="line"><span class="comment">  sumv 为所有物品的总价值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//bfs 来进行子集树的搜索。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,tcp,trp,trw;</span><br><span class="line">    queue&lt;Node&gt; q; <span class="comment">//创建一个普通队列(先进先出)</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">0</span>, sumv, W, <span class="number">1</span>)); <span class="comment">//压入一个初始结点</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) <span class="comment">//如果队列不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node livenode, lchild, rchild;<span class="comment">//定义三个结点型变量</span></span><br><span class="line">        livenode=q.<span class="built_in">front</span>();<span class="comment">//取出队头元素作为当前扩展结点livenode</span></span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="comment">//cp+rp&gt;bestp当前装入的价值+剩余物品价值小于当前最优值时，不再扩展。</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点的id值:&quot;</span>&lt;&lt;livenode.id&lt;&lt;<span class="string">&quot;当前结点的cp值:&quot;</span>&lt;&lt;livenode.cp&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前结点的解向量:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;livenode.x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        t=livenode.id;<span class="comment">//当前处理的物品序号</span></span><br><span class="line">        <span class="comment">// 搜到最后一个物品的时候不需要往下搜索。</span></span><br><span class="line">        <span class="comment">// 如果当前的购物车没有剩余容量(已经装满)了，不再扩展。</span></span><br><span class="line">        <span class="keyword">if</span>(t&gt;n||livenode.rw==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(livenode.cp&gt;=bestp)<span class="comment">//更新最优解和最优值</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">              &#123;</span><br><span class="line">                bestx[i]=livenode.x[i];</span><br><span class="line">              &#125;</span><br><span class="line">              bestp=livenode.cp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(livenode.cp+livenode.rp&lt;bestp)<span class="comment">//判断当前结点是否满足限界条件，如果不满足不再扩展</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//扩展左孩子</span></span><br><span class="line">        tcp=livenode.cp; <span class="comment">//当前购物车中的价值</span></span><br><span class="line">        trp=livenode.rp-goods[t].value; <span class="comment">//不管当前物品装入与否，剩余价值都会减少。</span></span><br><span class="line">        trw=livenode.rw; <span class="comment">//购物车剩余容量</span></span><br><span class="line">        <span class="keyword">if</span>(trw&gt;=goods[t].weight) <span class="comment">//满足约束条件，可以放入购物车</span></span><br><span class="line">        &#123;</span><br><span class="line">            lchild.rw=trw-goods[t].weight;</span><br><span class="line">            lchild.cp=tcp+goods[t].value;</span><br><span class="line">            lchild=<span class="built_in">Node</span>(lchild.cp,trp,lchild.rw,t+<span class="number">1</span>);<span class="comment">//传递参数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t;i++)</span><br><span class="line">            &#123;</span><br><span class="line">              lchild.x[i]=livenode.x[i];<span class="comment">//复制以前的解向量</span></span><br><span class="line">            &#125;</span><br><span class="line">            lchild.x[t]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(lchild.cp&gt;bestp)<span class="comment">//比最优值大才更新</span></span><br><span class="line">               bestp=lchild.cp;</span><br><span class="line">            q.<span class="built_in">push</span>(lchild);<span class="comment">//左孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扩展右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(tcp+trp&gt;=bestp)<span class="comment">//满足限界条件，不放入购物车</span></span><br><span class="line">        &#123;</span><br><span class="line">            rchild=<span class="built_in">Node</span>(tcp,trp,trw,t+<span class="number">1</span>);<span class="comment">//传递参数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t;i++)</span><br><span class="line">            &#123;</span><br><span class="line">              rchild.x[i]=livenode.x[i];<span class="comment">//复制以前的解向量</span></span><br><span class="line">            &#125;</span><br><span class="line">            rchild.x[t]=<span class="literal">false</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(rchild);<span class="comment">//右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestp;<span class="comment">//返回最优值。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入物品的个数和背包的容量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入物品的个数 n:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入购物车的容量W:&quot;</span>;</span><br><span class="line">    cin &gt;&gt; W;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请依次输入每个物品的重量w和价值v,用空格分开:&quot;</span>;</span><br><span class="line">    bestp=<span class="number">0</span>; <span class="comment">//bestv 用来记录最优解</span></span><br><span class="line">    sumw=<span class="number">0</span>; <span class="comment">//sumw为所有物品的总重量。</span></span><br><span class="line">    sumv=<span class="number">0</span>;   <span class="comment">//sum 为所有物品的总价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; goods[i].weight &gt;&gt; goods[i].value;<span class="comment">//输入第 i 件物品的体积和价值。</span></span><br><span class="line">        sumw+= goods[i].weight;</span><br><span class="line">        sumv+= goods[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sumw&lt;=W)</span><br><span class="line">    &#123;</span><br><span class="line">        bestp=sumv;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;放入购物车的物品最大价值为: &quot;</span>&lt;&lt;bestp&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;所有的物品均放入购物车。&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;放入购物车的物品最大价值为: &quot;</span>&lt;&lt;bestp&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;放入购物车的物品序号为: &quot;</span>;</span><br><span class="line">    <span class="comment">// 输出最优解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bestx[i])</span><br><span class="line">           cout&lt;&lt;i&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计算的限制"><a href="#计算的限制" class="headerlink" title="计算的限制"></a>计算的限制</h1><h2 id="问题的复杂性"><a href="#问题的复杂性" class="headerlink" title="问题的复杂性"></a>问题的复杂性</h2><p>Turing论题：一个问题是可计算的当且仅当它在图灵机上经过有限步骤后得到正确的结果。</p>
<p><strong>停机问题</strong>是典型的不可计算问题。</p>
<p><strong>易解问题</strong>：将可以在多项式时间（多项式时间复杂度）内求解的问题看做是易解问题，例如：排序问题、串匹配问题。</p>
<p><strong>难解问题：</strong>将需要指数时间求解的问题看做是难解问题。例如：汉诺塔问题、TSP问题。</p>
<p><strong>确定性算法：</strong>如果该算法在整个执行过程中，每一步只有一个确定的选择，并且对于同一输入实例运行算法，所得的结果严格一致，则称其为<strong>确定性算法</strong>。</p>
<p><strong>P类问题</strong>：其中的P的英文全程是：<strong>polynomial</strong>，其含义是“<strong>多项式</strong>”，如果对于某个判断行问题，存在一个正整数k，对于输入规模为n的实例，能够以O（n^k）的时间运行一个<strong>确定性算法</strong>，得到yes或者no的答案，则称这个问题为P类问题。</p>
<p>常见的基本的NP完全问题：图着色问题、哈密顿回路问题和TSP问题。</p>
<p>问：解决NP完全问题用什么技术？</p>
<p>答：用<strong>近似算法</strong>和<strong>概率算法</strong>。</p>
<h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><p><strong>基本思路</strong>：用近似最优解代替最优解，以换取算法设计上的简化和时间复杂度的降低。换言之，近似算法找到的可能不是一个最优解，但它总会待为求问题提供一个解，为了具有实用性，近似算法必须给出能够给出算法所产生的解与最优解之间的差别。</p>
<p><strong>适用范围</strong>：求解NP难问题。</p>
<h2 id="概率算法"><a href="#概率算法" class="headerlink" title="概率算法"></a>概率算法</h2><p><strong>基本思路：</strong></p>
<p>允许算法在执行过程中随机选择下一步该怎么走，同时允许结果以较小的概率出现错误，并以此为代价，获得算法运行时间的大幅度减少。</p>
<h3 id="蒙特卡罗型概率算法"><a href="#蒙特卡罗型概率算法" class="headerlink" title="蒙特卡罗型概率算法"></a>蒙特卡罗型概率算法</h3><p>蒙特罗卡型概率算法用于求解问题的准确解。</p>
<p>设p是一个实数，且1&lt;1/2&lt;p&lt;1。如果一个蒙特卡罗型概率算法对于问题的任一输入实例得到正确解的概率不小于p，则称该蒙特卡罗型概率算法是p正确的。</p>
<h3 id="拉斯维加斯型概率算法"><a href="#拉斯维加斯型概率算法" class="headerlink" title="拉斯维加斯型概率算法"></a>拉斯维加斯型概率算法</h3><p>设p(x)是对输入实例x调用拉斯维加斯型概率算法获得问题的一个解的概率，则一个正确的拉斯维加斯型概率算法应该对于所有的输入实例x均有p(x)&gt;0.</p>
<p>参考地址：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/merge-sort.html">归并排序</a></p>
<p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/117.html">快速排序</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/quick-sort.html">快速排序</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29867652">二叉树搜索树</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/124885051">堆排序</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99949110">二叉查找树</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/400584573">动态规划和贪心算法的异同</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linfangnan/p/14059868.html#%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3">多段图的最短路径问题</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/alps1992/category_2418987.html">阿里大佬讲算法</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136387766">最小生成树</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/BigJunOba/p/9247682.html">图</a></p>
</HR></HR></HR></HR></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CFuYuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://chenchuanze123.github.io/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">https://chenchuanze123.github.io/2022/06/07/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chenchuanze123.github.io" target="_blank">CFuYuan'sBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/">贪心法</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95/">动态规划法</a><a class="post-meta__tags" href="/tags/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/">分支限界法</a><a class="post-meta__tags" href="/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/">回溯法</a><a class="post-meta__tags" href="/tags/%E5%88%86%E6%B2%BB%E6%B3%95/">分治法</a><a class="post-meta__tags" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a><a class="post-meta__tags" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a><a class="post-meta__tags" href="/tags/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/">折半查找</a><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE/">二叉树查找</a><a class="post-meta__tags" href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/">堆排序</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E6%AE%B5%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/">多段图的最短路径问题</a></div><div class="post_share"><div class="social-share" data-image="/img/be2a0337711d4b5189245e6c670a2d5b.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/10/phpMyAdmin%E4%B8%AD%E7%9A%84MYSQL%E6%9C%8D%E5%8A%A1%E6%89%93%E4%B8%8D%E5%BC%80%EF%BC%9F/"><img class="prev-cover" src="/img/phpmyadmin.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">phpMyAdmin中的MYSQL服务打不开？| 无法登录DVWA 的问题 | Illegal mix of collations for operation ‘UNION‘</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E5%86%B301%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><img class="next-cover" src="/img/v2-40076bc7f96ed1580c25fd197c968c0e_r.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">详解动态规划解决01背包问题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/76c39a0fa42f4847eb2ef67b82932bc.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CFuYuan</div><div class="author-info__description">世界和平</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Chenchuanze123"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">这里是CFuYuan的博客，分享计算机的相关知识，以及自己的一些思考，欢迎一起交流学习:)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">算法基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%9A%EF%BC%88%E5%BF%85%E8%80%83%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">算法的五个特性：（必考）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AE%97%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">常用的描述算法的方法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">时间复杂度：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">基本的算法设计技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95%E4%B8%8E%E5%87%8F%E6%B2%BB%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">分治法与减治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">基本思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%B8%8E%E5%BC%82%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">同与异：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">适用范围：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">应用：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">快速排序：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">3.1.4.3.</span> <span class="toc-text">堆排序：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">3.1.4.4.</span> <span class="toc-text">折半查找：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%89%EF%BC%9A"><span class="toc-number">3.1.4.5.</span> <span class="toc-text">二叉查找树（二叉搜索树）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">3.1.4.6.</span> <span class="toc-text">插入排序：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B3%95%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">动态规划法与贪心法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%B8%8E%E5%BC%82%EF%BC%9A-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">同与异：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%9A-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">适用范围：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A-1"><span class="toc-number">3.2.4.</span> <span class="toc-text">应用：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%AE%B5%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.2.4.0.1.</span> <span class="toc-text">多段图的最短路径问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.2.4.0.2.</span> <span class="toc-text">01背包问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.2.4.0.3.</span> <span class="toc-text">最长公共子序列问题：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">最小生成树问题：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">基于搜索的算法设计技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">回溯法与分支限界法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A-2"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%B8%8E%E5%BC%82%EF%BC%9A-2"><span class="toc-number">4.1.2.</span> <span class="toc-text">同与异：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%9A-2"><span class="toc-number">4.1.3.</span> <span class="toc-text">适用范围：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A-2"><span class="toc-number">4.1.4.</span> <span class="toc-text">应用：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">4.1.4.0.1.</span> <span class="toc-text">图着色问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">4.1.4.0.2.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.4.0.3.</span> <span class="toc-text">哈密顿回路问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TSP%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">4.1.4.0.4.</span> <span class="toc-text">TSP问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.4.0.5.</span> <span class="toc-text">01背包问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">计算的限制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">问题的复杂性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">近似算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">概率算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E5%9E%8B%E6%A6%82%E7%8E%87%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">蒙特卡罗型概率算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E6%96%AF%E7%BB%B4%E5%8A%A0%E6%96%AF%E5%9E%8B%E6%A6%82%E7%8E%87%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.2.</span> <span class="toc-text">拉斯维加斯型概率算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/%E8%A7%A3%E5%86%B3hexo%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/" title="解决hexo图片不显示问题"><img src="/img/1460000038479998.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解决hexo图片不显示问题"/></a><div class="content"><a class="title" href="/2024/01/18/%E8%A7%A3%E5%86%B3hexo%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/" title="解决hexo图片不显示问题">解决hexo图片不显示问题</a><time datetime="2024-01-18T06:32:05.000Z" title="发表于 2024-01-18 14:32:05">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/%E6%88%91%E5%96%9C%E6%AC%A2%E4%BD%A0/" title="我喜欢你"><img src="/img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我喜欢你"/></a><div class="content"><a class="title" href="/2024/01/18/%E6%88%91%E5%96%9C%E6%AC%A2%E4%BD%A0/" title="我喜欢你">我喜欢你</a><time datetime="2024-01-18T06:25:00.000Z" title="发表于 2024-01-18 14:25:00">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/05/%E8%AE%B0%E5%BD%95%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Chat-GPT%E8%A7%A3%E5%86%B3%E6%AF%95%E8%AE%BE%E4%B8%AD%E7%9A%84BUG/" title="记录：第一次使用Chat-GPT解决毕设中的BUG"><img src="/img/ChatGPT_AIdisrupterpost.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记录：第一次使用Chat-GPT解决毕设中的BUG"/></a><div class="content"><a class="title" href="/2023/04/05/%E8%AE%B0%E5%BD%95%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Chat-GPT%E8%A7%A3%E5%86%B3%E6%AF%95%E8%AE%BE%E4%B8%AD%E7%9A%84BUG/" title="记录：第一次使用Chat-GPT解决毕设中的BUG">记录：第一次使用Chat-GPT解决毕设中的BUG</a><time datetime="2023-04-05T01:55:16.000Z" title="发表于 2023-04-05 09:55:16">2023-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/17/%E9%9F%A9%E9%A1%BA%E5%B9%B3%E8%80%81%E5%B8%88%E7%9A%84linux%E5%9F%BA%E7%A1%80%E8%AF%BE%EF%BC%88%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/" title="韩顺平老师的Linux基础课（复习笔记）"><img src="/img/LINUX-OS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="韩顺平老师的Linux基础课（复习笔记）"/></a><div class="content"><a class="title" href="/2023/01/17/%E9%9F%A9%E9%A1%BA%E5%B9%B3%E8%80%81%E5%B8%88%E7%9A%84linux%E5%9F%BA%E7%A1%80%E8%AF%BE%EF%BC%88%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89/" title="韩顺平老师的Linux基础课（复习笔记）">韩顺平老师的Linux基础课（复习笔记）</a><time datetime="2023-01-17T05:26:00.000Z" title="发表于 2023-01-17 13:26:00">2023-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/10/phpMyAdmin%E4%B8%AD%E7%9A%84MYSQL%E6%9C%8D%E5%8A%A1%E6%89%93%E4%B8%8D%E5%BC%80%EF%BC%9F/" title="phpMyAdmin中的MYSQL服务打不开？| 无法登录DVWA 的问题 | Illegal mix of collations for operation ‘UNION‘"><img src="/img/phpmyadmin.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="phpMyAdmin中的MYSQL服务打不开？| 无法登录DVWA 的问题 | Illegal mix of collations for operation ‘UNION‘"/></a><div class="content"><a class="title" href="/2022/07/10/phpMyAdmin%E4%B8%AD%E7%9A%84MYSQL%E6%9C%8D%E5%8A%A1%E6%89%93%E4%B8%8D%E5%BC%80%EF%BC%9F/" title="phpMyAdmin中的MYSQL服务打不开？| 无法登录DVWA 的问题 | Illegal mix of collations for operation ‘UNION‘">phpMyAdmin中的MYSQL服务打不开？| 无法登录DVWA 的问题 | Illegal mix of collations for operation ‘UNION‘</a><time datetime="2022-07-10T04:16:47.000Z" title="发表于 2022-07-10 12:16:47">2022-07-10</time></div></div></div></div></div></div></main><footer id="footer" style="background: flase"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">说点什么</p><div class="bg-ad"><div>随便说点什么说点什么随便说点什么说点什么随便说点什么说点什么随便说点什么说。</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://fe32.top/">点击跳转到哪儿</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">修仙导航</p><ul class="ft-links"><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CHUANZExiaodaima?spm=1011.2124.3001.5343">CSDN博客</a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BF%AE%E4%BB%99/3104855">百度修仙</a></li><li><a href="https://chenchuanze123.github.io/about/">关于博主</a><a href="https://chenchuanze123.github.io/archives/">文章归档</a></li><li><a href="https://chenchuanze123.github.io/categories/">文章分类</a><a href="https://chenchuanze123.github.io/tags/">文章标签</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/"><img src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div></div></div></div><div class="copyright">&copy;2020 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> CFuYuan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">在新的一天，愿我们知足且坚定，温柔且上进。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>