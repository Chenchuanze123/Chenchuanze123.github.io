<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础教程 | CFuYuan'sBlog</title><meta name="keywords" content="Java,编程语言"><meta name="author" content="CFuYuan"><meta name="copyright" content="CFuYuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一句话目标对于一些比较复杂或者第一眼看上去不太好理解的概念，我信奉的观念就是，用一句话把它解释清楚，而且是用很通俗的语言，当然了，如果你已经能够很好的理解了，还是建议用不是那么正式但又不是很通俗的语言解释。所以我接下来我会用一句话这个标签来解释这些难懂的概念。 C&#x2F;C++与Java编译运行过程对比：数据溢出：byte是一个字节的数据类型，所以它的表示范围是-128~127当我们此范围之外的数赋值给">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础教程">
<meta property="og:url" content="http://example.com/2021/12/11/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/index.html">
<meta property="og:site_name" content="CFuYuan&#39;sBlog">
<meta property="og:description" content="一句话目标对于一些比较复杂或者第一眼看上去不太好理解的概念，我信奉的观念就是，用一句话把它解释清楚，而且是用很通俗的语言，当然了，如果你已经能够很好的理解了，还是建议用不是那么正式但又不是很通俗的语言解释。所以我接下来我会用一句话这个标签来解释这些难懂的概念。 C&#x2F;C++与Java编译运行过程对比：数据溢出：byte是一个字节的数据类型，所以它的表示范围是-128~127当我们此范围之外的数赋值给">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3aa569df39d14808ba812ac74487fec0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li75Yqo5byP5a2m5Lmg5LiN6KKr5Yqo,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="article:published_time" content="2021-12-11T09:48:11.000Z">
<meta property="article:modified_time" content="2022-01-31T05:43:27.574Z">
<meta property="article:author" content="CFuYuan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/3aa569df39d14808ba812ac74487fec0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li75Yqo5byP5a2m5Lmg5LiN6KKr5Yqo,size_20,color_FFFFFF,t_70,g_se,x_16"><link rel="shortcut icon" href="/img/download.jpg"><link rel="canonical" href="http://example.com/2021/12/11/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: CFuYuan","link":"链接: ","source":"来源: CFuYuan'sBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础教程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-31 13:43:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="CFuYuan'sBlog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img-blog.csdnimg.cn/3aa569df39d14808ba812ac74487fec0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li75Yqo5byP5a2m5Lmg5LiN6KKr5Yqo,size_20,color_FFFFFF,t_70,g_se,x_16')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CFuYuan'sBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 文章分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-11T09:48:11.000Z" title="发表于 2021-12-11 17:48:11">2021-12-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-31T05:43:27.574Z" title="更新于 2022-01-31 13:43:27">2022-01-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础教程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一句话目标"><a href="#一句话目标" class="headerlink" title="一句话目标"></a>一句话目标</h1><p><em>对于一些比较复杂或者第一眼看上去不太好理解的概念，我信奉的观念就是，用一句话把它解释清楚，而且是用很通俗的语言，当然了，如果你已经能够很好的理解了，还是建议用不是那么正式但又不是很通俗的语言解释。</em><br>所以我接下来我会用<strong>一句话</strong>这个标签来解释这些难懂的概念。</p>
<p><strong>C/C++与Java编译运行过程对比：</strong><br><img src="https://img-blog.csdnimg.cn/3aa569df39d14808ba812ac74487fec0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li75Yqo5byP5a2m5Lmg5LiN6KKr5Yqo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>数据溢出：<br>byte是一个字节的数据类型，所以它的表示范围是-128~127<br>当我们此范围之外的数赋值给byte类型变量时，会发生数据溢出，溢出的方式就是<img src="https://img-blog.csdnimg.cn/c827b18a107e481184a7b4349de3bb07.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li75Yqo5byP5a2m5Lmg5LiN6KKr5Yqo,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>比127大的数要接着顺时针转，假如是128，比127大1，那就是移动一个数变成-128假如是129，比127大2，那就是移动两个数变成-127，这样以此类推；<br>比-128小的数要接着逆时针，假如是-129，比-128小1，那就移动一个数变成127，假如是-130，比-128小2，那就是移动两个数变成126，其他数据类型也以此类推。</p>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="编程语言的几个发展阶段"><a href="#编程语言的几个发展阶段" class="headerlink" title="编程语言的几个发展阶段"></a>编程语言的几个发展阶段</h2><p><strong>面向机器语言      ——》面向过程语言——》面向对象语言<br>（二进制、汇编）——》C语言           ——》Java语言</strong></p>
<p>在面向过程编程中我们是以“方法”为主体的<br>而面向对象编程汇总我们是以“对象”为主体的<br>在面向对象语言的学习过程中，一个简单的理念就是，需要完成某种任务的时候，我们首先想到是谁去完成（对象）；提到某个数据的时候，想到是谁的数据，这样也更符合我们日常生活中的描述。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类？类是干什么的呢？<br><strong>一句话</strong>：类是用来描述和抽象具有相同属性和行为的一类事物的概念，就比如说人类，猫类，狗类，家禽类，这些类中的动物都有相同的属性和行为。<br>那么如何声明一个类呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;		<span class="comment">//声明了一个人类</span></span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">	String Name;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">int</span> Age;</span><br><span class="line">	String Id;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员变量的赋值问题"><a href="#成员变量的赋值问题" class="headerlink" title="成员变量的赋值问题"></a>成员变量的赋值问题</h3><p>Java规定不能在类中对成员变量进行赋值，但是你可以在类中对成员变量赋初始值，要想对成员变量赋值必须要在方法体内部进行<br>举个列子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;		<span class="comment">//声明的同时赋初始值，正确</span></span><br><span class="line">	<span class="keyword">int</span> b;			</span><br><span class="line">	b = <span class="number">27</span>;			<span class="comment">//非法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		b = b-<span class="number">19</span>;	<span class="comment">//在类中赋值，正确</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的创建与构造方法"><a href="#对象的创建与构造方法" class="headerlink" title="对象的创建与构造方法"></a>对象的创建与构造方法</h2><p>类也可以看做是一种数据类型，也可以用来声明变量，而用类声明的变量被称为对象。<br>既然类有了，总得有对象来体现这个类的属性和行为吧，那我们就可以创建对象来体现了<br>创建对象要用关键字<code>new</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People zs;						<span class="comment">//声明对象张三</span></span><br><span class="line">People zs = <span class="keyword">new</span> People();		<span class="comment">//创建对象张三</span></span><br></pre></td></tr></table></figure>
<p>构造方法的名称必须与它坐在的类名称完全一致，而且没有类型，可以有参数，参数一般就是对对象的成员变量进行赋值。<br>所以这样看起来构造方法在创建对象以及对对象进行初始化起到了至关重要的作用。<br>构造方法可以有多个，但是其参数一定不同（参数类型、参数个数）。<br>构造方法不就是把对象的值赋值给实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;		<span class="comment">//创建了一个人类</span></span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">	<span class="comment">//注意：当没有指定成员变量的值时，其都有默认值，String为null，int为0，float为0.0，boolean为flase</span></span><br><span class="line">	String Name;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">int</span> Age;</span><br><span class="line">	String Id;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;	</span><br><span class="line"></span><br><span class="line">	People(String N)&#123;	<span class="comment">//构造函数</span></span><br><span class="line">		Name = N;</span><br><span class="line">	&#125;</span><br><span class="line">	People(String s)&#123;	<span class="comment">//构造函数</span></span><br><span class="line">		sex = s;</span><br><span class="line">	&#125;</span><br><span class="line">	People()&#123;			<span class="comment">//构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对象的内存模型"><a href="#对象的内存模型" class="headerlink" title="对象的内存模型"></a>对象的内存模型</h3><p>声明对象和创建对象是有区别的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">People zs;						<span class="comment">//声明对象张三</span></span><br><span class="line"><span class="comment">//声明对象，内存为空</span></span><br><span class="line"></span><br><span class="line">People zs = <span class="keyword">new</span> People();		<span class="comment">//创建对象张三，可以看做是new一个构造方法</span></span><br><span class="line"><span class="comment">/*创建对象，分配内存，先为成员变量</span></span><br><span class="line"><span class="comment">	String Name;</span></span><br><span class="line"><span class="comment">	boolean sex;</span></span><br><span class="line"><span class="comment">	int Age;</span></span><br><span class="line"><span class="comment">	String Id;</span></span><br><span class="line"><span class="comment">分配内存，如果未赋值再赋给默认值，最后new运算符会计算出一个引用值（地址值），即表达式new People()是一个值。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/cf381b5b6b8c4dc0a121ef5cff17fd2b.png" alt="声明对象"><br><img src="https://img-blog.csdnimg.cn/597f54eb1dd74dd99c0c8f71449b3641.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSq5LiK546E6YGT,size_20,color_FFFFFF,t_70,g_se,x_16" alt="创建对象"></p>
<p>这个内存模型啊，告诉我们一件事，声明和创建区别很大</p>
<h2 id="类与程序的基本结构"><a href="#类与程序的基本结构" class="headerlink" title="类与程序的基本结构"></a>类与程序的基本结构</h2><p>一个应用程序可以有多个源文件，一个源文件可以有多个类，但是一定要有一个主类<br><img src="https://img-blog.csdnimg.cn/95e56e55fbfe41d9807ed44c59b0676b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSq5LiK546E6YGT,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="参数传值"><a href="#参数传值" class="headerlink" title="参数传值"></a>参数传值</h2><p> 说一下<strong>引用型参数</strong><br>当参数是数组、对象、接口的时候，称之为引用型参数，传的是<strong>引用</strong>（地址）而不是实体<br>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span></span>&#123;			<span class="comment">//电池类</span></span><br><span class="line">	<span class="keyword">int</span> e;		<span class="comment">//电量</span></span><br><span class="line">	Battery(<span class="keyword">int</span> a)&#123;</span><br><span class="line">		e = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Radio</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">openRadio</span><span class="params">(Battery battery)</span></span>&#123;</span><br><span class="line">	 	battery.e = battery.e - <span class="number">10</span>;		<span class="comment">//消耗了电量</span></span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"> 	 	Battery b = <span class="keyword">new</span> Battery(<span class="number">100</span>);		<span class="comment">//创建一个电池对象,电量初始化为100</span></span><br><span class="line"> 	 	Radio r = <span class="keyword">new</span> Radio();			<span class="comment">//创建一个收音机对象</span></span><br><span class="line"> 	 	r.openRadio(b);					<span class="comment">//参数为电池对象b，此时就相当于把b的值赋给Battery Battery</span></span><br><span class="line"> 	 									<span class="comment">//而b = new Battery(),所以在方法openRadio中就相当于Battery battery = new Battery()</span></span><br><span class="line"> 	 									<span class="comment">//由上可知道对象b和battery他们两个是一模一样的，他们具有相同的引用，故具有完全相同的变量</span></span><br><span class="line"> 	 									<span class="comment">//并且battery就相当于b的复印件，复印件的改变不会影响原件</span></span><br><span class="line"> 	 									</span><br><span class="line"> 	 	</span><br><span class="line"> 	 &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h2><p><strong>一句话</strong>：将其他类的对象作为自己的成员变量<br>对象组合的本质就是一个类的数据成员变量存的不是基本的数据类型，而是一个对象的地址<br>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> rad;	<span class="comment">//半径</span></span><br><span class="line">	<span class="keyword">double</span> area;	<span class="comment">//面积</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	area = <span class="number">3.14</span>*r*r;</span><br><span class="line">	 	<span class="keyword">return</span> area;</span><br><span class="line">	 &#125;</span><br><span class="line">	Circle(<span class="keyword">double</span> r)&#123;</span><br><span class="line">	 	rad = r;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circular</span></span>&#123;		<span class="comment">//圆锥类</span></span><br><span class="line"></span><br><span class="line"> 	Circle bottom;</span><br><span class="line"> 	<span class="keyword">double</span> h;</span><br><span class="line"> 	</span><br><span class="line"> 	Circular(<span class="keyword">double</span> height)&#123;</span><br><span class="line"> 	 	h = height;</span><br><span class="line"> 	 &#125;</span><br><span class="line"> 	 <span class="function"><span class="keyword">void</span> <span class="title">setBottom</span><span class="params">(Circle c)</span></span>&#123;</span><br><span class="line"> 	  	bottom = c;</span><br><span class="line"> 	  &#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">double</span>	<span class="title">getVolme</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	 	<span class="keyword">if</span>(bottom == <span class="keyword">null</span>)</span><br><span class="line"> 	 		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> 	 	<span class="keyword">else</span></span><br><span class="line"> 	 		<span class="keyword">return</span> bottom.getArea()*h/<span class="number">3.0</span>;</span><br><span class="line"> 	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example0</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"> 	 	Circle c = <span class="keyword">new</span> Circle(<span class="number">100</span>);</span><br><span class="line"> 	 	Circular cu = <span class="keyword">new</span> Circular(<span class="number">20</span>);</span><br><span class="line"> 	 	cu.setBottom(c);</span><br><span class="line"> 	 	<span class="keyword">int</span> V = cu.getVolme();</span><br><span class="line"> 	 	System.out.println(<span class="string">&quot;圆锥的体积为：&quot;</span>+V);</span><br><span class="line"> 	 &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例成员与类成员"><a href="#实例成员与类成员" class="headerlink" title="实例成员与类成员"></a>实例成员与类成员</h2><p>首先类成员中的类变量被所有对象共享，也就是所有的对象的类变量是相同的一处内存空间，并且通过类名访问类变量和通过对象访问类变量都可以改变类变量的值。<br>加载类的字节码文件的时候，类变量已经分配了内存，而成员变量没有；当该类创建对象时，才会给实例对象分配内存</p>
<p>实例成员就是正常的变量和方法<br>类成员就是静态的变量和方法（前面加了static修饰的）<br><img src="https://img-blog.csdnimg.cn/c33df37929da4fe0b03b3929d29e11d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aSq5LiK546E6YGT,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>类变量也叫做static变量、静态变量、全局变量，我叫它共享变量，分配给这些对象的类变量占有相同的一处内存，改变其中一个对象的这个类变量，其他对象的这个类变量也会跟着变；static方法可以重写，重写就是子类可以重写父类已有的方法。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。</p>
<p>这里要强调一下：</p>
<ul>
<li>static修饰的成员变量和方法，从属于类</li>
<li>普通变量和方法从属于对象</li>
<li>静态方法不能调用非静态成员，编译会报错</li>
</ul>
<h3 id="static关键字的用途"><a href="#static关键字的用途" class="headerlink" title="static关键字的用途"></a>static关键字的用途</h3><p>一句话描述就是：方便在没有创建对象的情况下进行调用(方法/变量)。</p>
<p>显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p>
<p>static可以用来修饰类的成员方法、类的成员变量，另外也可以编写static代码块来优化程序性能</p>
<h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><p>static方法也成为静态方法，由于静态方法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有this的，因为不依附于任何对象，既然都没有对象，就谈不上this了，并且由于此特性，在静态方法中不能访问类的非静态成员变量和非静态方法，因为非静态成员变量和非静态方法都必须依赖于具体的对象才能被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法和静态成员变量。</span><br></pre></td></tr></table></figure>
<p><strong>代码示例</strong><br><img src="https://img-blog.csdnimg.cn/77e29a8e76b349b99854a29e3226a395.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>从上面代码里看出：</p>
<ul>
<li>静态方法test2()中调用非静态成员变量address，编译失败。这是因为，在编译期并没有对象生成，address变量根本就不存在。</li>
<li>静态方法test2()中调用非静态方法test1()，编译失败。这是因为，编译器无法预知在非静态成员方法test1()中是否访问了非静态成员变量，所以也禁止在静态方法中调用非静态成员方法</li>
<li>非静态成员方法test1()访问静态成员方法test2()/变量name是没有限制的</li>
</ul>
<p>所以，如果想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。最常见的静态方法就是main方法，这就是为什么main方法是静态方法就一目了然了，因为程序在执行main方法的时候没有创建任何对象，只有通过类名来访问。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">int</span> a;		<span class="comment">//类变量</span></span><br><span class="line"> 	<span class="keyword">float</span> b;			<span class="comment">//成员变量</span></span><br><span class="line"> 	</span><br><span class="line"> 	set_a(<span class="keyword">int</span> A)&#123;</span><br><span class="line"> 	 	a = A;</span><br><span class="line"> 	 &#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;	<span class="comment">//类方法</span></span><br><span class="line"> 	 	System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"> 	 &#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">int</span> <span class="title">d</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;	<span class="comment">//成员方法</span></span><br><span class="line"> 	 	<span class="keyword">int</span> c;</span><br><span class="line"> 	 	<span class="keyword">return</span> c = x*y;</span><br><span class="line"> 	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"> 	 	A.a = <span class="number">10</span>; 		<span class="comment">//通过类名给类变量a赋值,10</span></span><br><span class="line"> 	 	A a1 = <span class="keyword">new</span> A();</span><br><span class="line"> 	 	System.out.println(A.a);	<span class="comment">//输出10</span></span><br><span class="line"> 	 	a1.set_a(<span class="number">20</span>);	<span class="comment">//通过对象调用给类变量赋值，20</span></span><br><span class="line"> 	 	System.out.println(A.a);	<span class="comment">//输出20</span></span><br><span class="line"> 	 &#125;</span><br><span class="line"> 	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>实例方法和类方法的区别：</p>
<p> 1.</p>
<ul>
<li>有对象才有实例方法的入口地址；将类的字节码文件加载至jvm内存时，不会为实例方法分配内存；</li>
<li>但是会给类方法分配入口地址。多个对象的实例方法的入口是相同的，也就是实例方法的入口地址被共享；</li>
<li>只有在所有的对象被回收时，入口地址才会被取消；</li>
<li>而类方法的入口地址在程序退出的时候才被取消。</li>
</ul>
<p>2.</p>
<ul>
<li>可以把类变量放在实例方法中（把有static修饰的变量放在没有static修饰的方法中），也就是实例方法可以操作类变量；</li>
<li>但是类方法不可以操作实例变量；原因是：再类创建对象之前，实例成员变量还没有分配内存空间。</li>
</ul>
<ol start="3">
<li>static方法中只能有static变量</li>
</ol>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>顾名思义是对方法进行重新加载。<br>那么对哪些方法会重新加载呢？<br>同一个方法名，但是它们参数的类型不同，它们参数的个数不同。<br>这种例子很多啊，比如说</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">int</span> a,<span class="keyword">int</span> b);</span><br><span class="line">f();</span><br><span class="line">f(<span class="keyword">double</span> a,<span class="keyword">double</span> b);</span><br><span class="line"><span class="comment">//这三个方法如果放在同一个类中，那么就叫做对f进行方法重载</span></span><br></pre></td></tr></table></figure>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this是当前对象的引用，就是说当前用构造函数建的对象是谁，这个this就代表谁，它是一个引用。<br>this可以出现在：</p>
<ul>
<li>实例方法</li>
<li>构造方法</li>
<li>但是不可以出现在类方法中</li>
</ul>
<p>不就是你的方法的参数名跟你的成员变量名一样的时候，你要是执行语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">成员变量名=参数名</span><br></pre></td></tr></table></figure>
<p>就必须写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员变量名=参数名</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>通常情况下：可以省略成员变量名字前的“this.”，以及static变量前的“类名.”；</li>
<li>this不能出现在类方法中， 因为类方法可以通过类名直接调用，这时可能还没有对象诞生。<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2></li>
</ol>
<p>一句话说明包的目的：区分不同文件中相同类</p>
<h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><p>一句话：相当于C语言中的<code>#include</code>，就是导入在源程序中要用的各种库或者自己写好的接口。<br>也就是在同一目录下的Java文件是互通的，要通过import与其他包文件进行通讯。<br>在java中使用类库就是创建相应的对象（所以说Java是面向对象的语言）。<br>如果使用import导入了包中的所有类，那么会增加编译时间，但是不会影响程序的性能，因为jvm只加载自己程序要用的（可Java本来就慢啊= =）。</p>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p><img src="https://img-blog.csdnimg.cn/45abe9830c6a49ee8bbf192e7420f41f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>类方法总是可以操作类中的类变量，与访问控制符没有关系。</p>
<ol>
<li>public<br>被public标记的变量和方法在任何地方的对象都可以访问（类内部、本包、子类、外部包）</li>
<li>protected<br>被propected标记的变量和方法仅在本包内可以访问。</li>
<li>友好的<br>同上</li>
<li>private<br>只有类内部使用</li>
</ol>
<p>注：</p>
<ul>
<li>只能用public来修饰类</li>
<li>权限由高到低：public——&gt;protected——&gt;友好的——&gt;private</li>
</ul>
<p><strong>protected和友好型的区别：</strong><br>当子类和父类不在同一个包中时，父类中的private和友好访问权限的成员变量和方法不会被子类继承；在同一个包中时，子类会将父类的变量和方法除private之外全部继承。<br>如果子类和父类不在同一个包中，子类不继承父类的友好成员变量和方法</p>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>如果要一次定义很多对象，建议使用对象数组而不是定义多个对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h1 id="子类与继承"><a href="#子类与继承" class="headerlink" title="子类与继承"></a>子类与继承</h1><h2 id="子类与父类"><a href="#子类与父类" class="headerlink" title="子类与父类"></a>子类与父类</h2><p>既然我们的代码要描述我们的现实生活那么应该怎么做呢？我们显示生活中父亲生儿子这种事，那可是几乎都存在的啊，不管是人类，还是其他生物，几乎都存在，那就我们也让我们的代码可以继承，让我们原本定义的类，可以让他派生自己的子类，也就是让子类来继承父类的一些属性以及行为。（儿子只能有一个爹，爹却可以生很多儿子）<br>那么继承的关键字是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends</span><br></pre></td></tr></table></figure>
<p>最简单的例子啊,人类是个父类，学生类是个子类，那可以这么说:学生类继承了人类</p>
<h3 id="人类"><a href="#人类" class="headerlink" title="人类"></a>人类</h3><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><ul>
<li>姓名</li>
<li>性别</li>
<li>年龄</li>
<li>身份证号</li>
</ul>
<h4 id="行为："><a href="#行为：" class="headerlink" title="行为："></a>行为：</h4><ul>
<li>喝水</li>
<li>跑步</li>
<li>散步</li>
<li>吃饭</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">	String Name;</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">int</span> Age;</span><br><span class="line">	String Id;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么学生类要继承人类的话，就要把人类所有的属性都原封不动的继承过来，然后如果学生类有需求的话再在学生类中填入自己需要的属性或行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	String strID;		<span class="comment">//新添的属性学号</span></span><br><span class="line">	String Subject;		<span class="comment">//课程</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">exercise</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">//广播体操</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">finalExam</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">//期末考试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些属性和行为是新添加的，都是学生所特有的</p>
<h2 id="子类的继承性"><a href="#子类的继承性" class="headerlink" title="子类的继承性"></a>子类的继承性</h2><p><strong>在同一包中：</strong><br>在同一个包中子类继承父类时，不会继承private标记的成员变量和方法，但是会继承友好的成员变量和方法。（父亲的隐私可不兴看啊）<br><strong>不在同一包中：</strong><br>不在同一个包中的子类继承父类时，private和友好的成员变量和方法都不会继承。</p>
<p><strong>protected进一步说明的举例：</strong><br>我们有一个类D，还有一个类C</p>
<ul>
<li>D类中自己声明的protected成员变量和方法，只要D跟C在同一包中，则在C类中创建的D对象可以访问这些protected成员变量和方法；</li>
<li>D类继承自己父类的那些protected成员变量和方法，需要追溯到这些protected成员变量和方法所在的祖先类跟C类是否在同一包中，若在，则在C类中创建的D对象可以访问这些protected成员变量和方法，反之，则不可以。</li>
</ul>
<h2 id="子类与对象"><a href="#子类与对象" class="headerlink" title="子类与对象"></a>子类与对象</h2><p>创建子类对象时，jvm不仅会为<strong>子类的成员变量</strong>分配内存还会为<strong>父类的成员变量</strong>分配内存。<br>但是我们知道子类继承父类时，并不会全部东西都继承过来，有时候会因为不在同一个包中，protected、友好型和private都不能继承，那么父类这个时候为什么还要为这些不能继承的成员变量分配内存呢？<br>答案是：子类会用那些从父类继承过来的方法来<strong>操作</strong>这部分未继承的变量。</p>
<h2 id="成员变量的隐藏和方法重写"><a href="#成员变量的隐藏和方法重写" class="headerlink" title="成员变量的隐藏和方法重写"></a>成员变量的隐藏和方法重写</h2><p> 在子类继承父类的过程中，因为要继承两部分：变量和方法</p>
<ul>
<li>自己再写一遍父类有的变量就叫做隐藏  </li>
<li>自己再写一遍父类有的方法就叫重写</li>
</ul>
<h3 id="继承中成员变量的访问特点："><a href="#继承中成员变量的访问特点：" class="headerlink" title="继承中成员变量的访问特点："></a>继承中成员变量的访问特点：</h3><p>在父子 类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</p>
<ol>
<li>直接通过子类对象访问成员变量：也就是<code>对象.成员变量</code>，规则是：创建对象时，等号左边是谁，就优先使用谁，没有则向上找。</li>
<li>间接通过成员方法访问成员变量：该方法属于谁，就优先用谁，没有则向上找。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numFu = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用的是本类当中的，不会向下找子类的</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numZi = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodZi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为本类当中有num，所以这里用的是本类的num</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">直接通过子类对象访问成员变量：</span></span><br><span class="line"><span class="comment">    等号左边是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">间接通过成员方法访问成员变量：</span></span><br><span class="line"><span class="comment">    该方法属于谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ExtendsField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu fu = <span class="keyword">new</span> Fu(); <span class="comment">// 创建父类对象</span></span><br><span class="line">        System.out.println(fu.numFu); <span class="comment">// 只能使用父类的东西，没有任何子类内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Zi zi = <span class="keyword">new</span> Zi();</span><br><span class="line"></span><br><span class="line">        System.out.println(zi.numFu); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(zi.numZi); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等号左边是谁，就优先用谁</span></span><br><span class="line">        System.out.println(zi.num); <span class="comment">// 优先子类，200</span></span><br><span class="line"><span class="comment">//        System.out.println(zi.abc); // 到处都没有，编译报错！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个方法是子类的，优先用子类的，没有再向上找</span></span><br><span class="line">        zi.methodZi(); <span class="comment">// 200</span></span><br><span class="line">        <span class="comment">// 这个方法是在父类当中定义的，</span></span><br><span class="line">        zi.methodFu(); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</p>
<p> <font color=#ff2200 size=3 face="黑体">     创建的对象是谁，就优先用谁，如果没有则向上找。</font></p>
<p> 注意事项：<br>无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。</p>
<p> 如何理解这个隐藏呢？</p>
<p> <font color=#ff2200 size=3 face="黑体"> 就是我子类不是会继承你父类的部分变量吗？<br> 比如父类有一个变量：<br> public a；<br> 如果我在子类中也声明了public a ；<br> 那么子类从父类继承的a就会被隐藏。<br> 说白了就是你子类要是有的话就用自己的，可以不用父类的了（这个“不用”就可以理解隐藏），要是没有，那就用父类的。</font>)</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>方法：看等号右边（创建的是谁），就优先调用谁</li>
<li>变量：看等号左边是谁，就优先调用谁；看方法属于谁，就优先调用谁</li>
</ul>
<h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p><img src="https://img-blog.csdnimg.cn/b231f34e9fd04bc49cc542b8735b8db4.png" alt="在这里插入图片描述"><br>重写就是我子类重新写父类的一些同名方法，返回值和形参都不能改变。<strong>即外壳不变，核心重写</strong>！</p>
<h3 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h3><ul>
<li>参数列表与被重写方法的参数列表必须完全相同。</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为 final 的方法不能被重写。声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个类，则不能重写该类的方法。</li>
</ul>
<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。<br>最常用的地方就是构造器的重载。</p>
<h3 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则:"></a>重载规则:</h3><ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li> 被重载的方法可以改变返回类型； </li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常； </li>
<li>方法能够在同一个类中或者在一个子类中被重载。 </li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<h2 id="super关键字（super≈父类）"><a href="#super关键字（super≈父类）" class="headerlink" title="super关键字（super≈父类）"></a>super关键字（super≈父类）</h2><p>super关键字的用法有三种：<br>1.在子类的成员方法中，访问父类的成员变量。<br>2.在子类的成员方法中，访问父类的成员方法。<br>3.在子类的构造方法中，访问父类的构造方法。</p>
<p><strong>一句话说明作用：</strong><br>当你在子类的方法中需要访问父类的变量或者方法时，就需要使用super关键字来访问。<br>很显然super这个关键字也是跟继承、父类和子类有关的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">methodZi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">//父类中的num</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.method(); <span class="comment">//访问父类中的method</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <font color=#ff2200 size=3 face="黑体">注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。静态方法中不能使用 super 关键字。 </font></p>
<p>调用父类的方法语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.方法名(参数列表);</span><br></pre></td></tr></table></figure>

<p>如果是继承的方法，是没有必要使用 super 来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用 super 才能在子类中调用父类中的被重写的方法。</p>
<h2 id="final关键字（不变）"><a href="#final关键字（不变）" class="headerlink" title="final关键字（不变）"></a>final关键字（不变）</h2><ul>
<li>修饰类：不可以有子类</li>
<li>修饰方法：可以被继承，但继承后不能被重写。（老老实实继承）</li>
<li>修饰变量：变为常量</li>
</ul>
<p><strong>final 修饰类中的属性或者变量</strong>：</p>
<p>无论属性是基本类型还是引用类型，final 所起的作用都是变量里面存放的”值”不能变。</p>
<p>这个值，对于基本类型来说，变量里面放的就是实实在在的值，如 1，”abc” 等。</p>
<p>而引用类型变量里面放的是个地址，所以用 final 修饰引用类型变量指的是它里面的地址不能变，并不是说这个地址所指向的对象或数组的内容不可以变，这个一定要注意。</p>
<p>例如：类中有一个属性是 final Person p=new Person(“name”); 那么你不能对 p 进行重新赋值，但是可以改变 p 里面属性的值 p.setName(‘newName’);</p>
<p>final 修饰属性，声明变量时可以不赋值，而且一旦赋值就不能被修改了。对 final 属性可以在三个地方赋值：声明时、初始化块中、构造方法中，总之一定要赋值。</p>
<h2 id="Java-转型问题"><a href="#Java-转型问题" class="headerlink" title="Java 转型问题"></a>Java 转型问题</h2><p>Java 转型问题其实并不复杂，只要记住一句话：父类引用指向子类对象。<br>什么叫父类引用指向子类对象，且听我慢慢道来。</p>
<p>从 2 个名词开始说起：<strong>向上转型(upcasting)</strong> 、**向下转型(downcasting)**。</p>
<p>举个例子：有2个类，Father 是父类，Son 类继承自 Father。</p>
<p>第 1 个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> Son();   <span class="comment">// 这就叫 upcasting （向上转型)</span></span><br><span class="line"><span class="comment">// 现在 f1 引用指向一个Son对象</span></span><br><span class="line"></span><br><span class="line">Son s1 = (Son)f1;   <span class="comment">// 这就叫 downcasting (向下转型)</span></span><br><span class="line"><span class="comment">// 现在f1 还是指向 Son对象</span></span><br></pre></td></tr></table></figure>

<p>第 2 个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Father f2 = <span class="keyword">new</span> Father();</span><br><span class="line">Son s2 = (Son)f2;       <span class="comment">// 出错，子类引用不能指向父类对象</span></span><br></pre></td></tr></table></figure>

<p>你或许会问，第1个例子中：<code>Son s1 = (Son)f1</code>; 问为什么是正确的呢。</p>
<p>很简单因为 f1 指向一个子类对象，<code>Father f1 = new Son();</code> 子类 s1 引用当然可以指向子类对象了。</p>
<p>而 f2 被传给了一个 Father 对象，<code>Father f2 = new Father();</code> 子类 s2 引用不能指向父类对象。</p>
<p>总结：</p>
<p>1、父类引用指向子类对象，而子类引用不能指向父类对象。</p>
<p>2、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转换吗，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure>

<p>3、把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转换，如：</p>
<p>f1 就是一个指向子类对象的父类引用。把f1赋给子类引用 s1 即 <strong>Son s1 = (Son)f1</strong>;</p>
<p>其中 f1 前面的(Son)必须加上，进行强制转换。</p>
<h3 id="对象的上转型对象"><a href="#对象的上转型对象" class="headerlink" title="对象的上转型对象"></a>对象的上转型对象</h3><p> 通俗地讲即是将子类对象转为父类对象。</p>
<p> 上转型对象的特点：</p>
<ul>
<li>上转型对象不能操作子类新增的变量和方法</li>
<li>上转型对象可以访问子类继承或者隐藏的成员变量，也可以调用子类继承的方法或者重写的方法。</li>
<li>如果子类重写了父类的某个实例方法后，当上转型对象调用这个方法时，一定调用的是子类重写的，若子类重写了父类的static方法，则调用时只能调用父类的。</li>
<li>不可以将父类创建的对象的应用赋值给子类声明的对象（不能说：人是中国人）<br>举例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;animal eatting...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bird eatting...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;bird flying...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Animal b=<span class="keyword">new</span> Bird(); <span class="comment">//向上转型</span></span><br><span class="line">    b.eat(); </span><br><span class="line">    <span class="comment">//! error: b.fly(); b虽指向子类对象，但此时丢失fly()方法</span></span><br><span class="line">    dosleep(<span class="keyword">new</span> Male());</span><br><span class="line">    dosleep(<span class="keyword">new</span> Female());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的向上转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal b=<span class="keyword">new</span> Bird(); <span class="comment">//向上转型</span></span><br><span class="line">b.eat();</span><br></pre></td></tr></table></figure>

<p>此处将调用子类的 eat() 方法。原因：b 实际指向的是 Bird 子类，故调用时会调用子类本身的方法。</p>
<p>需要注意的是：<br> <font color=#ff2200 size=3 face="黑体"> 向上转型时 b 会遗失除与父类对象共有的其他方法。如本例中的 fly 方法不再为 b 所有。</font><br>因此输出结果：<code>bird eatting...</code></p>
<h3 id="对象的下转型对象"><a href="#对象的下转型对象" class="headerlink" title="对象的下转型对象"></a>对象的下转型对象</h3><p>与向上转型相反，即是把父类对象转为子类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;girl smile()...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MMGirl</span> <span class="keyword">extends</span> <span class="title">Girl</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;MMirl smile sounds sweet...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;MMirl c()...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Girl g1=<span class="keyword">new</span> MMGirl(); <span class="comment">//向上转型</span></span><br><span class="line">    g1.smile();</span><br><span class="line">    </span><br><span class="line">    MMGirl mmg=(MMGirl)g1; <span class="comment">//向下转型,编译和运行皆不会出错</span></span><br><span class="line">    mmg.smile();</span><br><span class="line">    mmg.c();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Girl g2=<span class="keyword">new</span> Girl();</span><br><span class="line"><span class="comment">//    MMGirl mmg1=(MMGirl)g2; //不安全的向下转型,编译无错但会运行会出错</span></span><br><span class="line"><span class="comment">//    mmg1.smile();</span></span><br><span class="line"><span class="comment">//    mmg1.c();</span></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">* CGirl smile sounds sweet...</span></span><br><span class="line"><span class="comment">* CGirl smile sounds sweet...</span></span><br><span class="line"><span class="comment">* CGirl c()...</span></span><br><span class="line"><span class="comment">* Exception in thread &quot;main&quot; java.lang.ClassCastException: com.wensefu.other1.Girl</span></span><br><span class="line"><span class="comment">* at com.wensefu.other1.Main.main(Girl.java:36)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span>(g2 <span class="keyword">instanceof</span> MMGirl)&#123;</span><br><span class="line">      MMGirl mmg1=(MMGirl)g2; </span><br><span class="line">      mmg1.smile();</span><br><span class="line">      mmg1.c();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Girl g1=new MMGirl(); //向上转型</span><br><span class="line">g1.smile();</span><br><span class="line">MMGirl mmg=(MMGirl)g1; //向下转型,编译和运行皆不会出错</span><br></pre></td></tr></table></figure>
<p>这里的向下转型是安全的。因为 g1 指向的是子类对象。</p>
<p>而</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Girl g2=new Girl();</span><br><span class="line">MMGirl mmg1=(MMGirl)g2; //不安全的向下转型,编译无错但会运行会出错</span><br></pre></td></tr></table></figure>

<p>运行出错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: com.wensefu.other1.Girl</span><br><span class="line">    at com.wensefu.other1.Main.main(Girl.java:36)</span><br></pre></td></tr></table></figure>

<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。<br>子类构造方法总是先调用父类的构造方法，你没写super（有参数），则默认你写了super（无参数）。<br>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass(int n)&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass 类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass(int n):&quot;</span>+n);</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass2 类继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass2()&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SubClass2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2(int n):&quot;</span>+n);</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuperSub</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass 类继承------&quot;</span>);</span><br><span class="line">    SubClass sc1 = <span class="keyword">new</span> SubClass();</span><br><span class="line">    SubClass sc2 = <span class="keyword">new</span> SubClass(<span class="number">100</span>); </span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass2 类继承------&quot;</span>);</span><br><span class="line">    SubClass2 sc3 = <span class="keyword">new</span> SubClass2();</span><br><span class="line">    SubClass2 sc4 = <span class="keyword">new</span> SubClass2(<span class="number">200</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------SubClass 类继承------</span><br><span class="line">SuperClass()</span><br><span class="line"><span class="function">SubClass</span></span><br><span class="line"><span class="function"><span class="title">SuperClass</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="title">SubClass</span><span class="params">(<span class="keyword">int</span> n)</span>:100</span></span><br><span class="line"><span class="function">------SubClass2 类继承------</span></span><br><span class="line"><span class="function"><span class="title">SuperClass</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">SubClass2</span></span><br><span class="line"><span class="function"><span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">SubClass2</span><span class="params">(<span class="keyword">int</span> n)</span>:200</span></span><br></pre></td></tr></table></figure>
<p>好像有点感觉了，我们将代码做一点改动，再次感受一下:<br>在<code>subClass（）</code>构造方法中添一句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>然后将父类有参数构造方法改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SuperClass(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass(int n)&quot;</span>+<span class="keyword">this</span>.n);</span><br></pre></td></tr></table></figure>
<p>再次运行,得到结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------SubClass 类继承------</span><br><span class="line">SuperClass(<span class="keyword">int</span> n)<span class="number">200</span></span><br><span class="line"><span class="function">SubClass</span></span><br><span class="line"><span class="function"><span class="title">SuperClass</span><span class="params">(<span class="keyword">int</span> n)</span>300</span></span><br><span class="line"><span class="function"><span class="title">SubClass</span><span class="params">(<span class="keyword">int</span> n)</span>:100</span></span><br><span class="line"><span class="function">------SubClass2 类继承------</span></span><br><span class="line"><span class="function"><span class="title">SuperClass</span><span class="params">(<span class="keyword">int</span> n)</span>300</span></span><br><span class="line"><span class="function">SubClass2</span></span><br><span class="line"><span class="function"><span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">SubClass2</span><span class="params">(<span class="keyword">int</span> n)</span>:200</span></span><br></pre></td></tr></table></figure>

<h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><p>首先多态是个跟继承有关的概念，<br>什么叫多态？<br>多态就是在描述生活<br>举个例子<br>多态就是我有一个动物类，然后动物类派生了两个子类，猫类和狗类<br>我当初在动物类中写了一个方法：发出叫声<br>很显然猫跟狗的叫声不一样，一个喵喵，一个汪汪，那么我当初在动物类中写的这个发出叫声的方法现在如果这两个子类要用的话，是不是就得在猫类和狗类里面重写了，重写完之后，这整个过程就叫做多态<br>多态就是 同一个方法的不同实现。</p>
<h2 id="abstract类和abstract方法"><a href="#abstract类和abstract方法" class="headerlink" title="abstract类和abstract方法"></a>abstract类和abstract方法</h2><p> 在java中我们用abstract关键字来表达抽象。举个例子：<br>我们说车子都可以跑(run)。但有几个轮子，怎么跑，对于不同的车有不同的结果。自行车需要人踩着跑，汽车发动机推动跑等等，那么我们可以车表达为抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 车子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自行车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;人踩着跑。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 汽车</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Automobile</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;发动机驱动跑。。。&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我的理解是抽象更像是一种概念，只要是抽象的就不需要具象，抽象类不需要实例化，抽象方法不需要在本类中实现。<br>抽象方法是一个概念，不用实现！！只要你在一个方法前冠以abstract，那这个方法就变成了一个概念，你不需要去实现一个概念。抽象方法跟接口中的方法是类似的，都不需要实现，所以我们没办法直接调用抽象方法</p>
<p> abstract类中声明的abstract方法要在子类中实现，如果子类未实现必须要将子类也声明为abstract：<br> <img src="https://img-blog.csdnimg.cn/6b495f4a67ba474bb0dbfc42af1b43a5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>abstract类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用<span class="keyword">abstract</span>关键字来表达的类，其表达形式为：（<span class="keyword">public</span>）<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、抽象类不能被实例化，也就是说我们没法直接<span class="keyword">new</span> 一个抽象类。抽象类本身就代表了一个类型，无法</span><br><span class="line">确定为一个具体的对象，所以不能实例化就合乎情理了，只能有它的继承类实例化。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、抽象类虽然不能被实例化，但有自己的构造方法（这个后面再讨论）</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、抽象类与接口（<span class="class"><span class="keyword">interface</span>）有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类</span></span><br><span class="line"><span class="class">中可以有实例方法，并实现业务逻辑，比如我们可以在抽象类中创建和销毁一个线程池。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">5、抽象类不能使用<span class="title">final</span>关键字修饰，因为<span class="title">final</span>修饰的类是无法被继承，而对于抽象类来说就是</span></span><br><span class="line"><span class="class">需要通过继承去实现抽象方法，这又会产生矛盾。（后面将写一篇关于<span class="title">finally</span>的文章详细讨论）</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>abstract方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、从上面的例子中我们可以看到抽象方法跟普通方法是有区别的，它没有自己的主体（没有&#123;&#125;包起来的</span><br><span class="line">业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、抽象方法不能用<span class="keyword">private</span>修饰，因为抽象方法必须被子类实现（覆写），而<span class="keyword">private</span>权限对于子类来</span><br><span class="line">说是不能访问的，所以就会产生矛盾</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、抽象方法也不能用<span class="keyword">static</span>修饰，试想一下，如果用<span class="keyword">static</span>修饰了，那么我们可以直接通过类名调</span><br><span class="line">用，而抽象方法压根就没有主体，没有任何业务逻辑，这样就毫无意义了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何使用抽象类和抽象方法：</span></span><br><span class="line"><span class="comment">1. 不能直接创建new抽象类对象。</span></span><br><span class="line"><span class="comment">2. 必须用一个子类来继承抽象父类。</span></span><br><span class="line"><span class="comment">3. 子类必须覆盖重写抽象父类当中所有的抽象方法。</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</span></span><br><span class="line"><span class="comment">4. 创建子类对象进行使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p> <font color=#ff2200 size=3 face="黑体">官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</font></p>
<p> 个人理解：接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）</p>
<h2 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h2><p>就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。</p>
<p>如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义子类，继承父类，实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h2 id="接口定义与实现"><a href="#接口定义与实现" class="headerlink" title="接口定义与实现"></a>接口定义与实现</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>定义接口用关键词<strong>interface</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在任何版本的Java中，接口都能定义抽象方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public abstract 返回值类型 方法名称(参数列表);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract</span></span><br><span class="line"><span class="comment">2. 这两个关键字修饰符，可以选择性地省略。（今天刚学，所以不推荐。）</span></span><br><span class="line"><span class="comment">3. 方法的三要素，可以随意定义。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceAbstract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这也是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。</span></span><br><span class="line"><span class="comment">从效果上看，这其实就是接口的【常量】。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">public static final 数据类型 常量名称 = 数据值;</span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">一旦使用final关键字进行修饰，说明不可改变。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 接口当中的常量，可以省略public static final，注意：不写也照样是这样。</span></span><br><span class="line"><span class="comment">2. 接口当中的常量，必须进行赋值；不能不赋值。</span></span><br><span class="line"><span class="comment">3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterfaceConst</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这其实就是一个常量，一旦赋值，不可以修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_OF_MY_CLASS = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceAbstractImpl</span> <span class="keyword">implements</span> <span class="title">MyInterfaceAbstract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是第一个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是第二个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是第三个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是第四个方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="abstract类与接口的比较"><a href="#abstract类与接口的比较" class="headerlink" title="abstract类与接口的比较"></a>abstract类与接口的比较</h2><p>在Java语言中，abstract class和interface是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。<br><img src="https://img-blog.csdnimg.cn/da79f0bad9794e67b5f08adc979b5926.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>1.相同点<br>A. 两者都是抽象类，都不能实例化。<br>B. interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。</li>
</ol>
<ol start="2">
<li><p>不同点<br> A. interface需要实现，要用implements，而abstract class需要继承，要用extends。<br> B. 一个类可以实现多个interface，但一个类只能继承一个abstract class。<br> C. interface强调特定功能的实现，而abstract class强调所属关系。<br> D. 尽管interface实现类及abstrct class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstract class的子类可以有选择地实现。<br> 这个选择有两点含义：<br> 一是Abastract class中并非所有的方法都是抽象的，只有那些冠有abstract的方法才是抽象的，子类必须实现。那些没有abstract的方法，在Abstrct class中必须定义方法体。<br> 二是abstract class的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以通过再次声明其方法为抽象的方式，无需实现，留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。<br> E. abstract class是interface与Class的中介。<br> interface是完全抽象的，只能声明方法，而且只能声明pulic的方法，不能声明private及protected的方法，不能定义方法体，也 不能声明实例变量。然而，interface却可以声明常量变量，并且在JDK中不难找出这种例子。但将常量变量放在interface中违背了其作为接 口的作用而存在的宗旨，也混淆了interface与类的不同价值。如果的确需要，可以将其放在相应的abstract class或Class中。<br> abstract class在interface及Class中起到了承上启下的作用。一方面，abstract class是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己 的实例变量，以供子类通过继承来使用。</p>
</li>
<li><p>interface的应用场合<br> A. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。<br> B. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。<br> C. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。<br> D. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。</p>
</li>
<li><p>abstract class的应用场合<br> 一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：<br> A. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。<br> B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。<br> C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CFuYuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/11/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">http://example.com/2021/12/11/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">CFuYuan'sBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/3aa569df39d14808ba812ac74487fec0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li75Yqo5byP5a2m5Lmg5LiN6KKr5Yqo,size_20,color_FFFFFF,t_70,g_se,x_16" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/14/%E6%97%B6%E5%BA%8F%E5%9B%BE%E4%B8%8E%E7%B1%BB%E5%9B%BE/"><img class="prev-cover" src="https://img-blog.csdnimg.cn/d5d26bfa747d484d8e4f0ace5a5b9449.png?x-oss-process=imag,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZmI5a-M5rqQ55qE5Y2a5a6i,size_20,color_FFFFFF,t_70,g_se,x_16" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">时序图与类图</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/24/%E4%BB%80%E4%B9%88%E6%98%AFAOP-%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82/"><img class="next-cover" src="https://img-blog.csdnimg.cn/a84990e47b984b06bed200e8d8776826.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZmI5a-M5rqQ55qE5Y2a5a6i,size_20,color_FFFFFF,t_70,g_se,x_16" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">什么是AOP(通俗易懂)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/12/%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/" title="上转型对象成员方法与变量的访问特点"><img class="cover" src="https://img-blog.csdnimg.cn/347fcba9226e41eeb133eeaca8ed9812.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZmI5a-M5rqQ55qE5Y2a5a6i,size_20,color_FFFFFF,t_70,g_se,x_16" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-12</div><div class="title">上转型对象成员方法与变量的访问特点</div></div></a></div><div><a href="/2022/01/05/Java%E7%BC%96%E7%A8%8B%E9%A2%98/" title="Java编程题"><img class="cover" src="/img/82046077.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-05</div><div class="title">Java编程题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CFuYuan</div><div class="author-info__description">修身 · 齐家 · 治国 · 平天下</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Chenchuanze123"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">这里是CFuYuan的博客，分享计算机的相关知识，以及自己的一些思考，欢迎一起交流学习:)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%9B%AE%E6%A0%87"><span class="toc-number">1.</span> <span class="toc-text">一句话目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">编程语言的几个发展阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">成员变量的赋值问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">对象的创建与构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">对象的内存模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">类与程序的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC"><span class="toc-number">2.5.</span> <span class="toc-text">参数传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">2.6.</span> <span class="toc-text">对象的组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E4%B8%8E%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">2.7.</span> <span class="toc-text">实例成员与类成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.8.</span> <span class="toc-text">static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">2.8.1.</span> <span class="toc-text">static关键字的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.2.</span> <span class="toc-text">static方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">2.9.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.10.</span> <span class="toc-text">this关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">2.11.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.12.</span> <span class="toc-text">import语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.13.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">2.14.</span> <span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.15.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">子类与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E4%B8%8E%E7%88%B6%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">子类与父类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%BA%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">人类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">属性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%EF%BC%9A"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">行为：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">3.2.</span> <span class="toc-text">子类的继承性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">子类与对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E9%9A%90%E8%97%8F%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.4.</span> <span class="toc-text">成员变量的隐藏和方法重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.4.1.</span> <span class="toc-text">继承中成员变量的访问特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.4.2.</span> <span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.4.3.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-number">3.5.</span> <span class="toc-text">重写与重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="toc-number">3.5.1.</span> <span class="toc-text">方法的重写规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="toc-number">3.5.2.</span> <span class="toc-text">重载规则:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88super%E2%89%88%E7%88%B6%E7%B1%BB%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">super关键字（super≈父类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%B8%8D%E5%8F%98%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">final关键字（不变）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E8%BD%AC%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">Java 转型问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.8.1.</span> <span class="toc-text">对象的上转型对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%8B%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.8.2.</span> <span class="toc-text">对象的下转型对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">3.9.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="toc-number">3.10.</span> <span class="toc-text">继承与多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract%E7%B1%BB%E5%92%8Cabstract%E6%96%B9%E6%B3%95"><span class="toc-number">3.11.</span> <span class="toc-text">abstract类和abstract方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">接口与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">接口的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">接口定义与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">接口定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">接口实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.4.</span> <span class="toc-text">abstract类与接口的比较</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/06/%E2%80%9C%E5%AD%A6%E5%8C%BB%E6%98%AF%E6%95%91%E4%B8%8D%E4%BA%86%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E2%80%9D/" title="“學醫是救不了中國人的”"><img src="/img/82046077.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="“學醫是救不了中國人的”"/></a><div class="content"><a class="title" href="/2022/02/06/%E2%80%9C%E5%AD%A6%E5%8C%BB%E6%98%AF%E6%95%91%E4%B8%8D%E4%BA%86%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E2%80%9D/" title="“學醫是救不了中國人的”">“學醫是救不了中國人的”</a><time datetime="2022-02-06T02:30:45.000Z" title="发表于 2022-02-06 10:30:45">2022-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/26/Vue%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="Vue基础教程"><img src="https://img-blog.csdnimg.cn/a4f569821abf4835a1d4fd8f0afc865b.png?x-oss-process=image,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZmI5a-M5rqQ55qE5Y2a5a6i,size_20,color_FFFFFF,t_70,g_se,x_16" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue基础教程"/></a><div class="content"><a class="title" href="/2022/01/26/Vue%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="Vue基础教程">Vue基础教程</a><time datetime="2022-01-26T13:09:30.000Z" title="发表于 2022-01-26 21:09:30">2022-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/12/%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/" title="上转型对象成员方法与变量的访问特点"><img src="https://img-blog.csdnimg.cn/347fcba9226e41eeb133eeaca8ed9812.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6ZmI5a-M5rqQ55qE5Y2a5a6i,size_20,color_FFFFFF,t_70,g_se,x_16" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="上转型对象成员方法与变量的访问特点"/></a><div class="content"><a class="title" href="/2022/01/12/%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9/" title="上转型对象成员方法与变量的访问特点">上转型对象成员方法与变量的访问特点</a><time datetime="2022-01-12T01:34:06.000Z" title="发表于 2022-01-12 09:34:06">2022-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Java%E8%AF%AD%E8%A8%80%E6%B1%82100%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/" title="Java语言求100以内的素数（详解）"><img src="https://img-blog.csdnimg.cn/3d4da26d68f040549bcc151bd0c4348b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_20,color_FFFFFF,t_70,g_se,x_16" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java语言求100以内的素数（详解）"/></a><div class="content"><a class="title" href="/2022/01/05/Java%E8%AF%AD%E8%A8%80%E6%B1%82100%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89/" title="Java语言求100以内的素数（详解）">Java语言求100以内的素数（详解）</a><time datetime="2022-01-05T08:57:12.000Z" title="发表于 2022-01-05 16:57:12">2022-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/05/Java%E7%BC%96%E7%A8%8B%E9%A2%98/" title="Java编程题"><img src="/img/82046077.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java编程题"/></a><div class="content"><a class="title" href="/2022/01/05/Java%E7%BC%96%E7%A8%8B%E9%A2%98/" title="Java编程题">Java编程题</a><time datetime="2022-01-05T08:06:58.000Z" title="发表于 2022-01-05 16:06:58">2022-01-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img-blog.csdnimg.cn/3aa569df39d14808ba812ac74487fec0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Li75Yqo5byP5a2m5Lmg5LiN6KKr5Yqo,size_20,color_FFFFFF,t_70,g_se,x_16')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By CFuYuan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>